Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: version B 2.10.1 6/24/83; site unisoft.UUCP
Path: utzoo!linus!decvax!decwrl!amd!dual!unisoft!fnf
From: fnf@unisoft.UUCP (fred fish)
Newsgroups: net.sources
Subject: EMACS-11 distribution
Message-ID: <361@unisoft.UUCP>
Date: Wed, 14-Nov-84 01:59:01 EST
Article-I.D.: unisoft.361
Posted: Wed Nov 14 01:59:01 1984
Date-Received: Fri, 16-Nov-84 01:35:18 EST
Organization: UniSoft Corp., Berkeley
Lines: 5748


Well, here is an EMACS-11 distribution.  This is my first
posting to net.sources so if I did something wrong please
don't crisp me.  Is there any advantage to breaking this
up into smaller pieces and posting separately?.


#--------CUT---------CUT---------CUT---------CUT--------#
#########################################################
#                                                       #
# This is a shell archive file.  To extract files:      #
#                                                       #
#    1)	Make a directory for the files.                 #
#    2) Write a file, such as "file.shar", containing   #
#       this archive file into the directory.           #
#    3) Type "sh file.shar".  Do not use csh.           #
#                                                       #
#########################################################
#
#
echo Extracting README:
sed 's/^Z//' >README <<\STUNKYFLUFF
Z(1)	Well folks, you asked for it and here it is.  Unfortunately it
Z	has been a couple years since I used any of this stuff so I'm a
Z	little rusty about what the various pieces are.  The following
Z	represents my best guess, going from memory and looking at some
Z	of the pieces.
Z
Z(2)	The following are considered to be a minimal usable distribution
Z	suitable for transmission over the net.  Note that there are two
Z	distinct flavors, one for VAX using VT100 and one for PDP-11 using
Z	VT52.
Z
Z
Z	     File	 Size			Usage
Z	--------------	------	-----------------------------------
Z
Z	README		 xxxxx	This file.
Z
Z	emacs.txt	 10659	"Quick reference" guide to EMACS-11
Z				commands.
Z
Z	emacs.doc	 65034	EMACS-11 documentation ready for
Z				printing.
Z
Z	emacs.src	 61032	EMACS-11 macro source file.  Use
Z				"vaxbld.tec" to compact into an
Z				executable macro file "emacs.tec".
Z				Use on VAX/VMS with VT100's.
Z
Z	vaxbld.tec	  1615	Used to compact "emacs.src" file into
Z				executable macro file "emacs.tec".
Z				Use on VAX/VMS with VT100.
Z
Z	emacs11.tec	 61166	Slightly modified version of "emacs.src".
Z				Use "bldemacs.tec" to compact into
Z				executable macro file "teco.tec".
Z				Use on PDP-11's with VT52's.
Z
Z	bldemacs.tec	  1558	TECO command file to compact the
Z				EMACS-11 macro source file "emacs11.tec"
Z				into an executable TECO macro file 
Z				"teco.tec" by removing all extraneous
Z				characters.  Use on PDP-11's.
Z
Z
Z(3)	The following files are available in the tape distribution only:
Z
Z
Z	     File	 Size			Usage
Z	--------------	------	-----------------------------------
Z
Z	MITemacs.doc	666989	Machine readable form of EMACS
Z				documentation for the TOPS-20
Z				version of EMACS.  (Available
Z				on tape distribution only)
Z
Z	ema.odl		  1183	Some kind of command file for one
Z				of the DEC operating systems.
Z				(I told you I was rusty!!!)
Z
Z	ema.tkb		  2778	Command file for building TECO
Z				under RSX-11 and/or VAX/VMS
Z
Z	emacs.rno	 54116	EMACS-11 manual in RUNOFF form.
Z
Z	emacs.tec	  4941	Compacted form of emacs.src
Z
Z	emacs11.doc	 40088	Earlier form of emacs.doc
Z
Z	teco.doc	711649	Machine readable form of documentation
Z				for TECO.
Z
Z	teco.tec	  4915	Compacted form of emacs11.tec
Z
Z	tioasm.cmd	   497	Another mysterious command file
Z
Z
Z
Z(4)	Some possibly helpful hints.
Z
Z	I seem to remember that the TECO source was modified slightly
Z	to look for "teco.tec" (or whatever you want to call the
Z	compacted macro file) in a special startup directory.  Thus
Z	when the TECO executable was copied to "ema" and invoked with
Z	the name "ema", it would automatically start up with the compacted
Z	macro file, otherwise you would get normal TECO.  It is possible
Z	to load the compacted macro file manually and start it up by
Z	hand each time, but I forget the exact procedure.
Z
Z	I think there are a couple terminal dependencies wired into
Z	the macro package, one for VT52 and one for VT100.
Z
Z	There were some problems with VMS trapping certain control
Z	characters that I was never able to completely fix.
Z
Z	The macro sources are in "structured TECO" (and I'll bet
Z	you thought TECO was an editor instead of a programming
Z	language!!).
Z
Z	Note that there are a couple embedded ESCAPE characters
Z	near the end of the macro source files "emacs11.tec" and
Z	"emacs.src".
Z
Z	HAVE FUN AND GOOD LUCK.
Z
Z
Z				Fred Fish
Z				UniSoft Systems Inc,
Z				Berkeley, Ca
Z				1-415-644-1230 ext 242
STUNKYFLUFF
set `sum README`
if test 21825 != $1
then
echo README: Checksum error. Is: $1, should be: 21825.
fi
#
#
echo Extracting bldemacs.tec:
sed 's/^Z//' >bldemacs.tec <<\STUNKYFLUFF
Z!  EMACSBLD.TEC --- TECO command file to strip the EMACS11.TEC !
Z!                   File of all extraneous characters such as !
Z!                   comments, blanks, tabs, and CRLF's.  This !
Z!                   results in TECO macro file called  !
Z!                   TECO.TEC which is of minimum possible size. !
Z
Z!  NOTE:  This file contains two non-printing characters; !
Z!         a pair of ESC's at the end !
Z
Z1^_&ED#2ED                 ! ^ means control in searchs; no yank prot !
ZET#64ET                    ! Run in detached mode !
Z@ER/EMACS11.TEC/           ! Open source file !
Z@EW/TECO.TEC/              ! Open destination file !
Z@_/!* START !/             ! Find the code start point !
Z0L
ZK
Z@^UI|
Z  A
Z  <
Z    .UB
Z    @^A%Removing comments%
Z    13^T
Z    10^T
Z    <
Z      @:S/!*/
Z      ;
Z      2R
Z      K
Z    > 
Z    QBJ
Z    @^A%Replacing CRLFs with blanks%
Z    13^T
Z    10^T
Z    <
Z      @:S/^EL/
Z      ;
Z      -1A-10"E
Z        -2D
Z        @I/ /
Z      '
Z    >
Z    QBJ
Z    @^A%Compressing blanks and tabs%
Z    13^T
Z    10^T
Z    <
Z      @:FS/^ES/ /
Z      ;
Z    >
Z    QBJ
Z    @^A%Restructuring lines%
Z    13^T
Z    10^T
Z    <
Z      Z-.-80U2
Z      Q2"G
Z        80C
Z        @:-FS/ //
Z        ;
Z        13@I//
Z        10@I//
Z      '
Z      -Q2;
Z    >    
Z    ^N"N
Z      @^A%EOF found%
Z      13^T
Z      10^T
Z      0;
Z    '
Z    @^A%Getting next page%
Z    13^T
Z    10^T
Z    A
Z  >
Z|
ZMI
ZEC
Z@EB/TECO.TEC/
ZMI
ZJ
Z@^A%Final blank compression%
Z13^T
Z10^T
Z<
Z  @:FS/ //
Z  ;
Z>
Z1ET
Z27^T
Z7^T
Z@^A% Done !!!%
Z13^T
Z10^T
ZEX
Z                         ! Close files and exit ! 
STUNKYFLUFF
set `sum bldemacs.tec`
if test 58310 != $1
then
echo bldemacs.tec: Checksum error. Is: $1, should be: 58310.
fi
#
#
echo Extracting emacs.doc:
sed 's/^Z//' >emacs.doc <<\STUNKYFLUFF
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z                            E  M  A  C  S  1  1
Z
Z
Z                     U  S  E  R  S     M  A  N  U  A  L
Z
Z
Z                        Screen oriented text editor
Z
Z
Z
Z
Z                           Version 1.4 (Vax/RSX)
Z
Z
Z                               by Fred Fish
Z
Z
Z
Z
Z                               (Preliminary)
Z
Z
Z                                 18-Jun-82
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 1
Z
Z                                  INTRODUCTION
Z
Z
Z
Z
Z           EMACS11 implements a small but powerful subset of the popu-
Z      lar  EMACS  editor  originally  developed  at  M.I.T.  This is a
Z      screen oriented editor, which unlike some others (VT52 or VTEDIT
Z      for  example),  does  not  make use of the auxilary keypad.  All
Z      command keys are placed where  they  are  the  most  convenient,
Z      under  the  user's fingertips, via the use of control characters
Z      and escape sequences.  Cursor keys are fine  for  some  applica-
Z      tions  but  moving the entire hand eight inches to reach them is
Z      not conducive to high speed editing.
Z
Z           The EMACS11 command set is easily learned; beginners can be
Z      doing  useful  editing in a matter of hours with only a dozen or
Z      so commands.  Since the source code is readily available (in the
Z      form  of TECO macros) internal user modifications and extensions
Z      are easily implemented.
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 2
Z
Z                            THE EMACS11 ENVIRONMENT
Z
Z
Z
Z      2.1  EMACS11 versus EMACS
Z
Z
Z           All references to EMACS are to the full  scale  version  of
Z      the  EMACS editor.  References to EMACS11 are to the PDP-11 sub-
Z      set written in TECO.
Z
Z
Z
Z      2.2  NOTES FOR VAX USERS
Z
Z
Z           Due to VMS's trapping of a wide variety  of  control  char-
Z      acters,  certain commands have been transported to other control
Z      characters until a VAX guru tells me how to turn off this inhos-
Z      pitable trait.  In particular, the VAX version uses:
Z
Z           1.  ^H for ^X
Z
Z           2.  ^I for ^Q
Z
Z           3.  ^T for ^S
Z
Z           4.  ^U for ^Y
Z
Z           Be warned that you may experience difficulities with multi-
Z      ple  command  sequences  on  the  VAX if any of the above listed
Z      characters are involved.
Z
Z           LATE NEWS FLASH ...  Just found out about the SET  TERMINAL
Z      /PASSALL  command  (what  can I say, I'm new to VAX).  This will
Z      let EMACS11 get all the characters you type but has  the  disad-
Z      vantage  of  making your interaction with the operating system a
Z      royal pain.  Now maybe someone will show me how to do the  equi-
Z      valent from a moving program.
Z
Z           The easiest way I have found to use the PASSALL and  NOPAS-
Z      SALL  terminal characteristics is to include the following lines
Z      in my LOGIN.COM file:
Z
Z
Z                  PA :== SET TERMINAL PASSALL
Z                  NP :== SET TERMINAL NOPASSALL
Z
Z
ZTHE EMACS11 ENVIRONMENT                                                 Page 2-2
Z
Z
Z
Z
Z      Then before invoking EMACS use the PA  command  and  immediately
Z      after exiting use the NP command.
Z
Z
Z
Z      2.3  CONVENTIONS
Z
Z
Z           This section describes some of the conventions used to des-
Z      cribe the EMACS11 command set and the command operations.
Z
Z
Z
Z      2.3.1  Control characters
Z
Z
Z           All references to control characters  will  use  the  carat
Z      character  ("^"), followed by the corresponding letter, to indi-
Z      cate a control character.  For example "^A" stands for the  con-
Z      trol/A  character,  which  is typed by simultaneously depressing
Z      the "CTRL" key and the "A" key.
Z
Z
Z
Z      2.3.2  Escape character
Z
Z
Z           The escape character, produced by depressing the "ESC" key,
Z      will  be  symbolized by the "$" symbol.  The "dollars character"
Z      occurs seldom enough that confusion is not  usually  a  problem.
Z      Thus  "$X" stands for a two character sequence which is typed by
Z      first depressing the "ESC" key and then the "X" key.  Note  that
Z      both keys ARE NOT depressed simultaneously.
Z
Z
Z
Z      2.4  COMMAND CLASSES
Z
Z
Z           EMACS11 commands are divided up into a basically hierarchi-
Z      al structure with the following classes:
Z
Z           1.  Control character commands
Z
Z           2.  Escape character commands
Z
Z           3.  ^X commands
Z
Z           4.  $X commands
Z
Z
Z
ZTHE EMACS11 ENVIRONMENT                                                 Page 2-3
Z
Z
Z
Z
Z      2.5  DEFINITIONS
Z
Z
Z           This section defines some of the terms  for  which  precise
Z      definitions  are required, in order to insure proper command op-
Z      eration or clarify their descriptions.
Z
Z
Z
Z      2.5.1  Cursor
Z
Z
Z           The cursor is the flashing underscore which appears beneath
Z      displayed text buffer characters (or flashing box which overlays
Z      characters).  The cursor is considered to be "at" the  character
Z      under which it is currently located.
Z
Z
Z
Z      2.5.2  Pointer
Z
Z
Z           The text buffer pointer is considered to be located between
Z      the  character  where  the  cursor is at, and the previous char-
Z      acter, if any.  Note that EMACS11 displays a graphics  character
Z      to  indicate  the end of the text buffer.  This character is not
Z      actually in the text buffer, even though the cursor may be posi-
Z      tioned to it.  When the cursor is at this special graphics char-
Z      acter, the pointer is at the end of the text buffer.
Z
Z
Z
Z      2.5.3  Word
Z
Z
Z           A word is any non-null string of characters which  contains
Z      no  imbedded blanks, tabs, line feeds, carriage returns, or form
Z      feeds.  Thus "++??"  is just as valid a  word  as  "cat".   Note
Z      that  any punctuation at either end of a word is also considered
Z      to be part of the word.
Z
Z
Z
Z      2.5.4  Sentence
Z
Z
Z           A sentence is any non-null string of words  with  the  last
Z      character  of  the last word being one of the following punctua-
Z      tion symbols:
Z
Z           1.  Period => "."
Z
Z           2.  Exclaimation mark => "!"
Z
ZTHE EMACS11 ENVIRONMENT                                                 Page 2-4
Z
Z
Z
Z
Z           3.  Question mark => "?"
Z
Z
Z
Z      2.5.5  Paragraph
Z
Z
Z           A paragraph is any non-null string of sentences  which  has
Z      one of the following paragraph delimiters at each end:
Z
Z           1.   Two or more successive  CRLFs  (carriage  return  line
Z               feed sequences)
Z
Z           2.   A form feed
Z
Z           3.   The top of the text buffer
Z
Z           4.   The bottom of the text buffer
Z
Z
Z
Z      2.5.6  Page 
Z
Z
Z           A page is any text (may be null, or no text) which has  one
Z      of the following page delimiters at each end:
Z
Z           1.   A form feed
Z
Z           2.   An imaginary "beginning of file mark"
Z
Z           3.   An end of file
Z
Z           Note that a page may be so large that  it  cannot  all  fit
Z      into the text buffer at one time, in which case EMACS11 commands
Z      which input or output pages treat the text currently in the text
Z      buffer  as one page, and the text in the input or output file as
Z      another page.  Conversely, several small pages may fit into  the
Z      text  buffer simultaneously.  Normal TECO treatment of formfeeds
Z      applies to EMACS11 commands except where noted.
Z
Z
Z
Z      2.5.7  Mark
Z
Z
Z           The mark is an imaginary "place holder" which may be  moved
Z      about in the text buffer at will.  It is initially at the top of
Z      the text buffer, until explicitly moved somewhere else.  Certain
Z      EMACS11  commands,  such as those which move pages in and out of
Z      the text buffer, affect the location of  the  mark  even  though
Z      they are not mark manipulation commands.
Z
Z
Z
ZTHE EMACS11 ENVIRONMENT                                                 Page 2-5
Z
Z
Z
Z
Z      2.5.8  Region
Z
Z
Z           A region is any text which is delimited by the mark and the
Z      current  pointer.  Such text is commonly refered to as a "marked
Z      region".
Z
Z
Z
Z      2.6  DISPLAY CHARACTERISTICS
Z
Z
Z
Z
Z      2.6.1  The status line
Z
Z
Z           When you first invoke EMACS11, via the EMA[cs] RSX11M  sys-
Z      tem command, your terminal's screen will be cleared and a status
Z      line will appear in the next to the last  line  at  the  bottom.
Z      This  line,  maintained by EMACS11, contains various information
Z      about the current state of the  editor,  including  the  version
Z      number,  the  mode, and the current input or output file.  If no
Z      input or output file is open, the file specification is omitted.
Z      If  only  an  input file is open, the file specification for the
Z      input file is shown.  If both an input and output file are open,
Z      the file specification for the output file is shown.
Z
Z
Z
Z      2.6.2  The prompt line
Z
Z
Z           The last line of the screen is used as a combination prompt
Z      line  and  error  message  line.  Very few EMACS11 commands will
Z      prompt for input since EMACS11 is designed to be command driven,
Z      not  ask  you  a bunch of questions.  Those that do will use the
Z      last line.  Other commands will also use this  line  to  confirm
Z      that  an  operation has been done, if such an operation does not
Z      cause a visible change in the text buffer  (such  as  setting  a
Z      mark).
Z
Z
Z
Z      2.6.3  Viewing information
Z
Z
Z           Certain EMACS11 commands allow you to "view" various  types
Z      of  information.  The view mode is characterized by three steps;
Z      (1) the screen being cleared, (2) the desired information  being
Z      shown, and (3) the text buffer window being restored.  View type
Z      commands do not change the text buffer or  the  current  pointer
Z      location.   EMACS11  discards  the  character used to end step 2
ZTHE EMACS11 ENVIRONMENT                                                 Page 2-6
Z
Z
Z
Z
Z      (any key depression except S or Q while screen  is  being  writ-
Z      ten).
Z
Z
Z                                    NOTE
Z
Z           If a given view commands seems to perform erratically,
Z           sometimes  working  and  sometimes not, it is probably
Z           because if the requested information does  not  exist,
Z           the command is ignored.
Z
Z
Z
Z
Z
Z      2.7  REPEAT COUNTS
Z
Z
Z           Most commands for which a repeat count makes sense  can  be
Z      preceded  with  a repeat count of the form $<digits>.  For exam-
Z      ple, $10N will move the pointer down  10  lines.   Also,  $100XE
Z      will execute the previously defined macro 100 times.
Z
Z
Z                                    NOTE
Z
Z           In particular, "commands" which do nothing except  in-
Z           sert their character into the text buffer (such as the
Z           "A" command) can also be preceded with a repeat count.
Z           This  the  command  $80* will insert 80 "*" characters
Z           into the text buffer at the current pointer location.
Z
Z
Z
Z
Z
Z      2.8  UNIMPLEMENTED COMMANDS
Z
Z
Z           It is possible that this manual may describe EMACS commands
Z      which  have  not yet been inplemented in the EMACS11 macros.  If
Z      this occurs, it is because it was felt that  no  self-respecting
Z      subset should be without that particular command, or that it was
Z      important enough to "reserve" it's future implementation's  name
Z      by  including  it  in  this manual.  Note that any unimplemented
Z      command  will  simply  be  ignored  (while  also   ringing   the
Z      terminal's  bell).   As of the current date only a small percen-
Z      tage of the commands in this manual have yet to be implemented.
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 3
Z
Z                               INSTALLING EMACS11
Z
Z
Z
Z
Z           The EMACS11 distribution kit includes all  files  necessary
Z      to  build  a version of TECO which has been slightly modified to
Z      support EMACS11.  The TECO source files are from the  TECO  ver-
Z      sion 35 distribution kit.
Z
Z
Z
Z      3.1  MODIFYING TECO; VERSION 35
Z
Z
Z           One of the things which must be modified  in  TECO  is  the
Z      display  of the new task size when an extend task is successful.
Z      This causes a hardware scrolling of the VT52, which has the  ef-
Z      fect of moving the status line up into the text area, and gener-
Z      ally screwing up the display.  The modification simply  comments
Z      out the code responsible for displaying the new task size.
Z
Z
Z
Z      3.2  REQUIRED TECO MACRO FILES
Z
Z
Z           The following TECO macro files are used:
Z
Z           1.   EMACS11.TEC -- This is the source file for  the  EMACS
Z               editor,  in  the  form of TECO macros.  It must be pro-
Z               cessed (purified) by BLDEMACS.TEC before it  is  useful
Z               as a macro file.
Z
Z           2.    BLDEMACS.TEC  --  This  macro   file   purifies   the
Z               EMACS11.TEC  file by stripping out all extraneous char-
Z               acters such as comments, blanks, and tabs.  The result-
Z               ing  macro code is approximate 4K characters and is the
Z               EMACS11 editor.
Z
Z
Z
Z               3.3  DEVIATIONS FROM EMACS
Z
Z
Z                    The realities of implementing an EMACS  subset  on
Z               the PDP-11, along with restrictions imposed by the TECO
Z               "programming language", have resulted in various  minor
Z               deviations  of some EMACS11 commands from their equiva-
ZINSTALLING EMACS11                                                      Page 3-2
Z
Z
Z
Z
Z               lent EMACS operation.  In general though,  such  devia-
Z               tions  are  quite minor, and only apparent to those who
Z               are intimately familiar with the EMACS command set.
Z
Z                    One area where deviations or extensions  are  very
Z               apparent is in the handling of file I/O.  The EMACS im-
Z               plementation is usually capable of handling a  file  in
Z               its entirity, with any required paging operations invi-
Z               sible to the user.  The EMACS11  command  set  includes
Z               some commands which manipulate pages.
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 4
Z
Z                           CONTROL CHARACTER COMMANDS
Z
Z
Z
Z
Z           Control character commands are  invoked  by  simultaneously
Z      holding down the "CTRL" key and the desired command key.
Z
Z
Z
Z      4.1  ^A -- Go to start of line
Z
Z
Z           The ^A command moves the pointer to the  beginning  of  the
Z      current  line  on  the screen.  If the pointer is already at the
Z      beginning, it has no effect.  
Z
Z
Z
Z      4.2  ^B -- Go back one character
Z
Z
Z           The ^B command moves the pointer back one character in  the
Z      text.   Note  that  the end of the line delimiter which is input
Z      with the RETURN key actually consists of two characters, a  car-
Z      riage  return (CR) and a line feed (LF).  Thus if you are at the
Z      beginning of the line and issue the ^B command, the pointer will
Z      be  placed between the CR and the LF characters, which can cause
Z      some confusion for beginners since the cursor will seem to  jump
Z      to  the  beginning of the previous line on the first ^B and then
Z      the end of that line on the second ^B.  (No you didn't find your
Z      first bug...sorry.)
Z
Z
Z
Z      4.3  ^D -- Delete next character
Z
Z
Z           The ^D command deletes the character immediately after  the
Z      current  pointer location.  If there is no character there, when
Z      at the end of the buffer for example, it is ignored.  Note  that
Z      this  operation  is  different  than that produced by the DELETE
Z      key, which deletes the character before the current pointer  lo-
Z      cation.  In general you will find that both commands are equally
Z      useful, and the appropriate command usage becomes second  nature
Z      with time.
Z
Z
Z
ZCONTROL CHARACTER COMMANDS                                              Page 4-2
Z
Z
Z
Z
Z      4.4  ^E -- Go to end of line
Z
Z
Z           The ^E command moves the pointer to the end of the  current
Z      line,  just  prior  to the CRLF (carriage return/line feed).  If
Z      the pointer is already positioned before a CRLF, the command  is
Z      ignored.
Z
Z
Z
Z      4.5  ^F -- Go forward one character
Z
Z
Z           The ^F command moves the  pointer  forward  one  character.
Z      When  at  the  end  of  the text buffer this command is ignored.
Z      Note that the comments for the complimentary command ^B apply to
Z      the ^F command.
Z
Z
Z
Z      4.6  ^G -- PANIC BUTTON
Z
Z
Z           The ^G command is your PANIC BUTTON.  It is generally  use-
Z      ful  in  getting you out of places you don't want to be.  It can
Z      be used at any time you are not at TECO level,  and  will  abort
Z      any  half entered commands.  The terminal's bell is used to con-
Z      firm your ^G has been recognized.
Z
Z
Z
Z      4.7  ^K -- Kill to end of line
Z
Z
Z           The ^K command performs one of two functions depending upon
Z      the  current  pointer  position.  When the pointer is not at the
Z      end of the current line (immediately before the CRLF)  then  the
Z      rest  of  the  line up to, but not including, the CRLF is erased
Z      from the text buffer and either  placed  into  the  kill  buffer
Z      (successive  kills  without  cursor  movement commands append to
Z      anything currently in the kill buffer).  When the pointer is  at
Z      the end of the current line, only the CRLF is killed.
Z
Z
Z
Z      4.8  ^N -- Go down to next line
Z
Z
Z           The ^N command attempts to move the cursor  directly  down-
Z      wards to the same relative location in the next line.  This will
Z      not always be successful, if for example the next line is short-
Z      er  or  contains  tabs below the current position.  See the com-
Z      ments in the complementary command ^P
ZCONTROL CHARACTER COMMANDS                                              Page 4-3
Z
Z
Z
Z
Z      4.9  ^O -- Open blank line
Z
Z
Z           The  ^O  command  "opens"  a  blank  line  for   insertion.
Z      Actually,  all  it  does is insert a CRLF at the current pointer
Z      position, but unlike simply entering a CRLF with the RETURN key,
Z      leaves  the  pointer  positioned before the CRLF, just where you
Z      want it for insertion of text.  When used at  the  beginning  of
Z      the  current  line,  the effect seen by the user is that a blank
Z      line is created by moving the current line downwards.  When used
Z      inside  a  line, the effect seen is that the rest of the line is
Z      moved downwards to a new line by itself, and the user  can  then
Z      finish the current line with different text.
Z
Z
Z                        *** NOT OPERABLE ON VAX ***
Z
Z
Z
Z      4.10  ^P -- Go up to previous line
Z
Z
Z           The ^P command attempts to move the  pointer  directly  up-
Z      wards  to  the  save relative position in the previous line.  If
Z      this fails, when the previous line is shorter that  the  current
Z      line  for example, the pointer is positioned as far to the right
Z      as possible without passing the location in the  original  line.
Z      Tabs  and  different  line lengths will effect where the pointer
Z      ends up.  Experiment with the command for further information.
Z
Z
Z
Z      4.11  ^Q -- Quote next character
Z
Z
Z           The ^Q command tells EMACS11  to  use  the  next  character
Z      typed as text.  The control and escape characters can be entered
Z      into the text buffer by simply preceding them with a ^Q command.
Z      Note  that  like most other commands, the ^Q command can be pre-
Z      ceded with a repeat count of the form ESC<digits>.
Z
Z
Z                            *** Is ^I on VAX ***
Z
Z
Z
Z      4.12  ^R -- Reverse search
Z
Z
Z           The ^R command does a reverse incremental search.   Reverse
Z      means  that the search progresses backwards from the current po-
Z      inter location.  Incremental means that  the  search  begins  as
Z      soon as the first character after the ^R is typed, and continues
ZCONTROL CHARACTER COMMANDS                                              Page 4-4
Z
Z
Z
Z
Z      as each search string character is input.  That is, ^R  then  an
Z      "A"  would  position the pointer to immediately before the first
Z      "A" character preceding the current  pointer  location.   Typing
Z      another  "A"  character would search for an position the pointer
Z      immediately before the first "AA" string preceding the  original
Z      pointer  location  (not current pointer location).  This type of
Z      searching may sound rather confusing on paper but in practice is
Z      extremely  useful,  since only the smallest number of characters
Z      required to locate a given string need be entered.
Z
Z           The ^R search sequence is terminated by the  first  control
Z      character entered (I.E.  an EMACS11 command) which is not anoth-
Z      er ^R or a ^S, or by the first ESC.  Note  that  if  an  ESC  is
Z      used, it DOES NOT count as the first character in an EMACS11 es-
Z      cape sequence command.  It  simply  terminates  the  search  and
Z      leaves the pointer at it's current position.
Z
Z           The ^G command has a special  significance  inside  the  ^R
Z      search  operation.   It aborts the search and leaves the pointer
Z      at its original location, before invocation of the  ^R  command,
Z      and  not  at  the current search location.  So if you don't find
Z      what you are looking for, use the ^G command to abort the search
Z      and  put  you  back  where  you started from.  Note that in this
Z      usage the ^G does not ring the terminal bell.
Z
Z           If the first character after a ^R  command  is  another  ^R
Z      then the previous successful EMACS11 search string is resurrect-
Z      ed and used for the current search.  If any characters intervene
Z      between  the ^R which starts the search, and the second ^R, then
Z      the current search string is reused  which  has  the  effect  of
Z      finding the next occurance of that string.  I.E.  if you input a
Z      sequence of the form "^R A B O ^R ^R ^R" then, assuming that you
Z      had  some "ABO" strings to look for, the pointer will end up im-
Z      mediately prior to the fourth occurance backwards from the  ori-
Z      ginal  location.  Again, experimentation will fix these concepts
Z      in mind much firmly than a lengthy discourse.   These  featurers
Z      are  mentioned for completeness of the command definition and to
Z      make the reader aware of their existence.
Z
Z
Z                                    NOTE
Z
Z           The ^R command is not yet full functional, however the
Z           forward search command ^S is.
Z
Z
Z
Z
Z
ZCONTROL CHARACTER COMMANDS                                              Page 4-5
Z
Z
Z
Z
Z      4.13  ^S -- Forward search
Z
Z
Z           The ^S command functions identically to the ^R command with
Z      the  exception that the search procedes in the FORWARD direction
Z      and the pointer is left AFTER the search string.  See  the  com-
Z      ments in the ^R command definition for further information.
Z
Z
Z
Z      4.14  ^V -- Move window down
Z
Z
Z           The ^V command moves the window into the text buffer  down-
Z      wards  by  the  appropriate  number of lines to cause a two line
Z      overlap with the previous window.  The cursor is left at the be-
Z      ginning  of  the  14th  line in the window, or at the end of the
Z      buffer if there is nothing else left to display.
Z
Z
Z
Z      4.15  ^W -- Kill marked region
Z
Z      The ^W command kills the currently marked  region  (see  REGIONS
Z      section  for  defintion) and puts it into, or appends it to, the
Z      kill buffer.  One way to move large blocks of text around is  to
Z      place  the text in a marked region, kill it with the ^W command,
Z      go to the new location, and unkill it with  the  ^Y  (yank  kill
Z      buffer)  command.   If the text buffer is very full this command
Z      is the frequent source of "memory overflow" aborts back to  TECO
Z      level.   If  this  occurs, then use the "M I ESC ESC" command to
Z      return to EMACS11, and the appropriate EMACS11 commands to write
Z      out portions of your text buffer to the output file.
Z
Z
Z
Z      4.16  ^Y -- Unkill previous kill
Z
Z
Z           The ^Y command performs the "unkill" operation by restoring
Z      the  contents  of the kill buffer at the current location.  Note
Z      that the kill buffer is not effected, so one way of  duplicating
Z      a  block  of  text is to kill it with the ^K or ^W commands, and
Z      then unkill it a number of times with the ^Y command.   The  po-
Z      inter  is  left  after  the unkilled text.  If the unkilled text
Z      consists of a large number of lines, successive ^Y commands  may
Z      appear  to have no effect (since the screen does not change) but
Z      appearances can be deceiving.  (Ya been warned!)
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 5
Z
Z                        SINGLE CHARACTER ESCAPE COMMANDS
Z
Z
Z
Z
Z           These commands are invoked by first hitting the ESC key and
Z      THEN  the given command key.  DO NOT hold the ESC key down while
Z      simultaneously pressing the command key.
Z
Z
Z
Z      5.1  $A -- Go back to sentence beginning
Z
Z
Z           The $A command searches backwards, from the current pointer
Z      position,  for  the first occurance of a sentence delimiter (see
Z      DEFINITIONS section for exact definition of  a  sentence  delim-
Z      iter),  or  the  top of the text buffer, whichever occurs first.
Z      The pointer is then moved to immediately before the next  alpha-
Z      betic  character  (A-Z or a-z), provided it would no move beyond
Z      the original location, in which case the command is aborted.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.2  $B -- Go back one word
Z
Z
Z           The $B command searches backwards, from the current pointer
Z      position,  for  the first occurance of a word delimiter (see DE-
Z      FINITIONS section for exact definition of a word delimiter),  or
Z      the top of the text buffer, whichever occurs first.  The pointer
Z      is then moved to immediately before the  next  alphabetic  char-
Z      acter (A-Z or a-z), provided it would not move beyond the origi-
Z      nal location, in which case the command is aborted.
Z
Z
Z
Z      5.3  $C -- Capitalize next word
Z
Z
Z           The $C command searches forward for the next word,  and  if
Z      found  moves  the  pointer  to  just before its first character.
Z      That character is then converted to upper case.  If no next word
Z      exists the command is aborted.
Z
Z
ZSINGLE CHARACTER ESCAPE COMMANDS                                        Page 5-2
Z
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.4  $D -- Delete next word
Z
Z
Z           The $D command searches forward for the next word,  and  if
Z      found  deletes  it, and any blanks or tabs which precede it.  If
Z      the pointer is currently positioned inside  a  word,  after  the
Z      first character, then the search does not begin until the end of
Z      that word.  If the seach fails, the pointer is left unchanged.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.5  $E -- Go forward to sentence beginning
Z
Z
Z           The $E command searches forward for the next  occurance  of
Z      the  beginning of a sentence, and if found, positions the cursor
Z      on the first character of that sentence which is  not  a  white-
Z      space  character.   If the search fails, the pointer is left un-
Z      changed.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.6  $F -- Go forward one word
Z
Z
Z           The $F command searches forward for the next word,  and  if
Z      found  positions  the  cursor  on  its  first character.  If the
Z      search fails the pointer is left unchanged.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.7  $G -- Go to specified line number
Z
Z
Z           The $G command moves the pointer to the  beginning  of  the
Z      line  specified by the repeat argument.  I.E., for this command,
Z      the repeat argument is used to furnish the line number  to  move
Z      to.   If  the repeat argument is omitted, the default value of 1
Z      is used.  This command is not a standard EMACS command.
Z
Z
Z
ZSINGLE CHARACTER ESCAPE COMMANDS                                        Page 5-3
Z
Z
Z
Z
Z      5.8  $H -- Mark paragraph
Z
Z
Z           The $H command causes the mark to be positioned before  the
Z      first  character of the current paragraph (the one which the po-
Z      inter is currently in) and the pointer to  be  positioned  after
Z      the last character of the current paragraph.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.9  $K -- Kill word
Z
Z
Z           The $K command searches forward for the next word,  and  if
Z      found  kills  it from the text buffer.  If the pointer must move
Z      to get to start of the next word, then  the  word  replaces  the
Z      current  kill  buffer  contents, otherwise it is appended to the
Z      kill buffer.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.10  $L -- Lower case next word
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.11  $N -- Go to next page
Z
Z
Z           The $N command first insures that both an input and  output
Z      file  is open, and if so, writes out the current text buffer and
Z      reads in the next page from the input file.   Normal  TECO  han-
Z      dling  of  formfeeds is used, that is, if a form feed occurs the
Z      read is terminated and the form feed is NOT put  in  the  buffer
Z      (it  IS appended to the current buffer contents on the next pag-
Z      ing operation).
Z
Z
Z
Z      5.12  $S -- Center text in screen
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
ZSINGLE CHARACTER ESCAPE COMMANDS                                        Page 5-4
Z
Z
Z
Z
Z      5.13  $T -- Exchange words
Z
Z
Z           The $T command exchanges the words before and after the po-
Z      inter,  and  leaves  the  pointer at the end of the second word.
Z      The net effect is as if the pointer "dragged" the word before it
Z      though  the  word  after it.  If the pointer is not currently at
Z      the end of a word, it is backed up until it finds the end  of  a
Z      word.   If no end of a word is found, the command is aborted and
Z      the pointer is returned to its original location.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.14  $U -- Upper case next word
Z
Z
Z
Z
Z      5.15  $V -- Move window up
Z
Z
Z           The $V command tries to  move  the  window  into  the  text
Z      buffer  up  by  sufficient  number of lines so that there is a 2
Z      line overlap with the previous window.  When the current  window
Z      is near the top of the buffer this may not be possible, in which
Z      case the window is moved so that it displays the top 23 lines in
Z      the text buffer.
Z
Z
Z
Z      5.16  $W -- Kill marked region
Z
Z
Z           The $W command kills the current marked region  and  either
Z      appends  it the current top of the kill stack, or pushes it onto
Z      the kill stack, depending  upon  whether  the  pointer  has  not
Z      moved, or has moved since the last kill.  
Z
Z
Z
Z      5.17  $Y -- Pop kill stack and unkill
Z
Z
Z           When used immediately after a ^Y command,  the  $Y  command
Z      wipes  the  last resurrected text from the buffer, pops the kill
Z      stack, and resurrects the second most recent kill.  When used at
Z      any  other time this command is ignored.  Note that the most re-
Z      cent kill, which was popped off the kill stack, is discarded and
Z      thus  lost  forever.  Also note that at this time the kill stack
Z      is only two kills deep.
ZSINGLE CHARACTER ESCAPE COMMANDS                                        Page 5-5
Z
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.18  $Z -- Return to TECO level
Z
Z
Z           The $Z command provides a "clean" way  to  return  to  TECO
Z      level.   Once at TECO level you can issue whatever TECO commands
Z      you wish then return to EMACS level with the MI$$ command.
Z
Z
Z                                    NOTE
Z
Z           While at TECO level you must not change  the  contents
Z           of  any of the alphabetic Q-registers (A-Z) or unpred-
Z           ictable results will occur when  you  try  to  restart
Z           EMACS.   Also,  any  changes you make via TECO will be
Z           totally  unknown  to  EMACS.   Particularly  dangerous
Z           changes  are  those  which open files, close files, or
Z           change any of TECO's status words.  Those which simply
Z           change  the  pointer  or  the text buffer contents are
Z           safe.
Z
Z
Z
Z
Z
Z      5.19  $^Y -- Insert last TECO command
Z
Z
Z           The $^Y command pulls the most recently defined  TECO  com-
Z      mand  (defined  via  the  $$ command) into the text buffer.  The
Z      TECO command is not effected.  This can be useful  for  interac-
Z      tively testing TECO macros and when the correct operation is ob-
Z      tained, pulling them into the text buffer and then writing  them
Z      out  to  a file via the commands which append or prepend defined
Z      regions to a specific file.
Z
Z
Z
Z      5.20  $^W -- Append next kill
Z
Z
Z           The $^W command is provided to override the EMACS mechanism
Z      which  causes the kill stack to be pushed when a new kill should
Z      replace the most recent kill.  This occurs any time the  pointer
Z      has  been moved since the last kill command.  By killing text in
Z      one location, moving the pointer to another  location,  issueing
Z      the $^W command, and killing some more text, you can concatenate
Z      text, from two or more different areas of the  text  buffer,  in
Z      the top of the kill stack.
Z
Z
Z
ZSINGLE CHARACTER ESCAPE COMMANDS                                        Page 5-6
Z
Z
Z
Z
Z      5.21  $$ -- Enter TECO command
Z
Z
Z           The $$ command prompts for a TECO command line  to  be  en-
Z      tered,  and  then executes it.  The current version of TECO will
Z      cause the terminal to perform hardware  scrolling  if  the  TECO
Z      command  line  contains  any  character  which causes a new line
Z      (such as form feed or line feed).  This will mess up the  status
Z      line  and  you will need to trigger a screen refresh with the ^L
Z      command.
Z
Z
Z
Z      5.22  $@ -- Set mark
Z
Z
Z           The $@ command in EMACS11 is equivalent to the  ^@  command
Z      in  EMACS.   Since  ^@ is actually the NULL character (ASCII 0),
Z      which is ignored by TECO, this command had to be moved.  $@  was
Z      available  (not  defined  in  EMACS) and seemed like the logical
Z      choice.
Z
Z           The $@ command sets the mark equal to the  current  pointer
Z      location.   At  present there is only one mark.  Moving the mark
Z      destroys the previous mark, which is initially at the top of the
Z      buffer.
Z
Z
Z
Z      5.23  $* -- View last TECO command
Z
Z
Z           The $* command tests to see if any TECO  command  has  been
Z      previously  defined.  If so, the screen is cleared and that com-
Z      mand is displayed starting at the top of the  screen.   Pressing
Z      any  key  erases the screen again and redisplays the text buffer
Z      window.  The text buffer is no effected and the  character  used
Z      to complete the command is discarded.
Z
Z
Z
Z      5.24  $% -- Query replace
Z
Z
Z           The $% command searches forward from  the  current  pointer
Z      location  to  find  the  next  occurance of the specified search
Z      string (prompted for).  The screen is then updated to  show  the
Z      current  pointer  position  and EMACS11 waits for the next char-
Z      acter to be input.  If it is a blank (space bar depressed)  then
Z      the  target  string  is  replaced with the specified replacement
Z      string (which is also prompted for).  Depressing any  other  key
Z      aborts  the  current  replacement  and the next occurance of the
Z      string is searched for.  The command can be aborted at any  time
ZSINGLE CHARACTER ESCAPE COMMANDS                                        Page 5-7
Z
Z
Z
Z
Z      with  a ^G command, which returns the pointer to the location it
Z      was at when the $% command was invoked.
Z
Z
Z
Z      5.25  $? -- Describe next command
Z
Z
Z           The $?  command tells EMACS to search the appropriate files
Z      for a definition of the EMACS command which follows it.  For ex-
Z      ample, the command sequence "$?^A" will  view  documentation  of
Z      the  ^A  command.   If the command sequence which follows the $?
Z      command is not recognized, the help command is aborted.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.26  $[ -- Go to beginning of paragraph
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.27  $] -- Go to end of paragraph
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      5.28  $< -- Go to beginning of text buffer
Z
Z
Z           The $< command moves the pointer to the top of the  current
Z      text  buffer.   If  the pointer is already at the top, it has no
Z      effect.
Z
Z
Z
Z      5.29  $> -- Go to end of text buffer
Z
Z
Z           The $> command moves the pointer to the bottom of the  cur-
Z      rent  text  buffer.  If the pointer is already at the bottom, it
Z      has no effect.
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 6
Z
Z                               CONTROL X COMMANDS
Z
Z
Z
Z
Z           The ^X command sequences consist of the ^X command followed
Z      by another character.
Z
Z
Z                                    NOTE
Z
Z           On the VAX, ^X has temporarily been transported to the
Z           ^H character.  Substitute ^H for all occurances of ^X.
Z
Z
Z
Z
Z
Z      6.1  ^X^L -- Lower case marked region
Z
Z
Z           The ^X^L command converts all alphabetic  characters  (A-Z)
Z      in the
Z
Z
Z
Z      6.2  ^X^N -- Get next page; with overlap
Z
Z
Z           The ^X^N command moves all text above the currently displa-
Z      yed  window  to  the output file, then reads in the next page of
Z      the input file.  If a form feed is needed between pages,  it  is
Z      inserted  into  the  text  buffer.  This command is particularly
Z      useful for editing near page boundries, where you  may  need  to
Z      jump back and forth between pages.
Z
Z
Z
Z      6.3  ^X^O -- Delete blank lines
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
ZCONTROL X COMMANDS                                                      Page 6-2
Z
Z
Z
Z
Z      6.4  ^X^P -- Mark current page
Z
Z
Z           The ^X^P command puts the pointer at the top of the  buffer
Z      or  after the first form feed backwards from the current pointer
Z      location, and puts the mark at the end of the  buffer  or  after
Z      the next form feed forwards from the current pointer location.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      6.5  ^X^R -- Read in file
Z
Z
Z           The ^X^R command causes the specified file to be opened for
Z      input  only.   To open an output file you must use the ^X^W com-
Z      mand, or make some change in the buffer and  then  try  to  exit
Z      EMACS, at which point you will be given the option of saving the
Z      buffer.
Z
Z
Z
Z      6.6  ^X^S -- Save file
Z
Z
Z           The ^X^S command writes to the output file the current text
Z      buffer contents and any remaining pages from the input file.  It
Z      then closes the input and output files, reopens the output  file
Z      with backup, and reads in the first page.
Z
Z
Z
Z      6.7  ^X^U -- Upper case marked region
Z
Z
Z           The ^X^U command converts all alphabetic  characters  (A-Z)
Z      in the
Z
Z
Z
Z      6.8  ^X^V -- Visit file
Z
Z
Z           The ^X^V command opens a file, with backup, for both  input
Z      and  output.  I.E., the output file specification is the same as
Z      the input file specification except that the version  number  of
Z      the output file is one greater than that of the input file.
Z
Z
Z
ZCONTROL X COMMANDS                                                      Page 6-3
Z
Z
Z
Z
Z      6.9  ^X^W -- Write file
Z
Z
Z           The ^X^W command closes any currently open output file  and
Z      opens  the  specified file for output.  It performs no other ac-
Z      tion.  This slightly different than the normal EMACS  definition
Z      of the ^X^W command.
Z
Z
Z
Z      6.10  ^X^X -- Exchange mark and pointer
Z
Z
Z           The ^X^X command exchanges the current  mark  and  pointer.
Z      If  the  mark has not yet been set it defaults to the top of the
Z      buffer.  This command is particularly useful for verifying  that
Z      a  marked  region is really where you expect it to be.  A second
Z      ^X^X restores the original mark and pointer locations.
Z
Z
Z
Z      6.11  ^XA  -- Append next page to buffer
Z
Z
Z           The ^XA command simply appends the next page of  the  input
Z      file  to the current buffer.  If no input file is currently open
Z      then this command is ignored.
Z
Z
Z
Z      6.12  ^XE  -- Execute last EMACS11 macro
Z
Z
Z           The ^XE command re-executes the last  EMACS  macro  defined
Z      with  the ^X( and ^X) commands.  This command may be preceded by
Z      a repeat count but be aware that EMACS macros execute relatively
Z      slowly.   This does not mean you should not use them, since they
Z      are one of the most powerful features of EMACS,  just  that  you
Z      should  not  expect quick results.  Note the use of the ^XT com-
Z      mand to toggle a screen update after each execution.
Z
Z
Z                                    NOTE
Z
Z           At the present time EMACS  macros  CANNOT  be  nested.
Z           That    is,   one   macro   cannot   define   another.
Z           Indeterminate results will occur if you  try  to  nest
Z           EMAC macros.
Z
Z
Z
Z
Z
ZCONTROL X COMMANDS                                                      Page 6-4
Z
Z
Z
Z
Z      6.13  ^XI  -- Insert file at pointer
Z
Z
Z           The ^XI command inserts the specified file at  the  current
Z      pointer  location.   In  order  to insure that a memory overflow
Z      does not occur  it  effectively  performs  a  simultaneous  ^X^S
Z      EMACS11  command,  so  an output file must be open.  If not, the
Z      ^XI command is simply ignored.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      6.14  ^XN  -- Output text above window
Z
Z
Z           The ^XN command first insures that an output  file  exists,
Z      and  if so, writes all text in the buffer above the current win-
Z      dow to the output file.  This is very handy for making some room
Z      in  the  buffer  when a significant portion is above the current
Z      window.  If no output file exists, the command is ignored.
Z
Z
Z
Z      6.15  ^XQ  -- Query inside EMACS11 macro
Z
Z
Z           When encountered inside an EMACS  macro,  the  ^XQ  command
Z      halts  execution  and waits for the next character from the key-
Z      board.  Pressing the space bar allows the current macro to  con-
Z      tinue  but does not flush any repeat count.  A ^G will abort the
Z      current macro and also any remaining repeat  count.   Any  other
Z      key  will simply abort the current macro but leave the remaining
Z      repeat count uneffected.  This is useful for selectively execut-
Z      ing the rest of a macro once part of it has been executed, as in
Z      a search and replace operation.
Z
Z
Z
Z      6.16  ^XT  -- Toggle redisplay inside macro
Z
Z
Z           The ^XT command causes the terminal screen  to  be  updated
Z      after  each execution of a keyboard macro.  In normal operation,
Z      the screen is not updated until after all requested  repetitions
Z      of  a macro have been executed.  This can be very unsettling for
Z      long running macros since the user  may  become  paranoid  about
Z      what  the macro is doing to his files.  By refreshing the screen
Z      after each execution, the results are displayed after each  exe-
Z      cution of the macro, so that the user can follow the macros pro-
Z      gress through the file.  The tradeoff is that  use  of  the  ^XT
Z      command  signicantly  increases  macro execution time.  When not
ZCONTROL X COMMANDS                                                      Page 6-5
Z
Z
Z
Z
Z      inside a macro, the ^XT command is simply ignored.
Z
Z
Z                                    NOTE
Z
Z           The ^XT command is not a normal EMACS command.   There
Z           is  no  command currently defined in the EMACS command
Z           set which supplies this function.
Z
Z
Z
Z
Z
Z      6.17  ^X(  -- Begin EMACS11 macro collection
Z
Z
Z           The ^X( command tells EMACS11 that all  following  commands
Z      until  the  matching ^X) command are to be collected in a buffer
Z      and remembered as a macro.  Note that the commands ARE  EXECUTED
Z      at the same time, so you can see the effects of the macro as you
Z      define it.  This is very convenient for long complicated macros.
Z      Hint:   be  sure  the  pointer ends up in a convenient place for
Z      macro repetitions.  At the current time, macros CANNOT be  nest-
Z      ed.   Nasty  things may occur if you try it.  Also note that the
Z      status line mode word changes to "Learn" while you are inside  a
Z      macro  definition.   Some  versions  of  EMACS  do this and some
Z      don't.
Z
Z
Z
Z      6.18  ^X)  -- End EMACS11 macro collection
Z
Z
Z           The ^X) command terminates an EMACS11 macro collection.  If
Z      no macro collection is in progress, the command is ignored.
Z
Z
Z
Z      6.19  ^X*  -- View last EMACS11 macro
Z
Z
Z
Z
Z      6.20  ^X=  -- Display location information
Z
Z
Z           The ^X= command displays information about the current  lo-
Z      cation  of the pointer.  At present, it displays the line number
Z      that the pointer is located in, and the number of characters  to
Z      the left of the pointer, in the current line.
Z
Z
Z
ZCONTROL X COMMANDS                                                      Page 6-6
Z
Z
Z
Z
Z      6.21  ^X   -- Kill back to start of sentence
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      6.22  ^X$  -- Re-execute last TECO command
Z
Z
Z           The ^X$ command re-executes the last TECO  command  defined
Z      with  the  EMACS11  $$ command.  It will NOT re-execute the last
Z      TECO command executed at the TECO level.
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 7
Z
Z                               ESCAPE X COMMANDS
Z
Z
Z
Z      7.1  $XA -- Append marked region to file
Z
Z
Z           The $XA command creates a  new  version  of  the  specified
Z      file,  transfers  all  text from the old version to the new ver-
Z      sion, and then appends the current marked region  to  that  file
Z      before  closing  it.   If the specified file does not exist, the
Z      command is ignored.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      7.2  $XC -- Enter/exit see-all mode
Z
Z
Z           See-all mode is a display mode  in  which  ALL  characters,
Z      both  printing  and  normally non-printing, are displayed on the
Z      terminal.  The non-printing characters are displayed as  special
Z      graphics  characters.   This is very handy for finding imbedding
Z      non-printing characters in text files.  (Compilers  are  usually
Z      good at that also, but not as nice about it.)
Z
Z
Z
Z      7.3  $XD -- Insert system date
Z
Z
Z           The $XD command inserts the current system date at the  po-
Z      inter  location in the form MM-DD-YY.  The pointer is left posi-
Z      tioned after the inserted date.
Z
Z
Z
Z      7.4  $XI -- Insert a file at pointer
Z
Z
Z           The $XI command inserts the specified file at  the  current
Z      pointer  location.   In  order  to insure that a memory overflow
Z      does not occur  it  effectively  performs  a  simultaneous  ^X^S
Z      EMACS11  command,  so  an output file must be open.  If not, the
Z      $XI command is simply ignored.
Z
Z
ZESCAPE X COMMANDS                                                       Page 7-2
Z
Z
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      7.5  $XL -- Load EMACS11 macro from file
Z
Z
Z           The $XL command loads the EMACS11  macro  buffer  from  the
Z      specified file.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      7.6  $XO -- View occurances of string
Z
Z
Z           This command will view all lines, from the current  pointer
Z      location to the end of the text buffer, which contain a specific
Z      string.  As with other view commands, it is terminated with  any
Z      single  keystroke.   If there are no occurances of the specified
Z      string, the command is aborted.
Z
Z
Z
Z      7.7  $XP -- Prepend marked region to file
Z
Z
Z           The $XP command creates a  new  version  of  the  specified
Z      file,  writes  out  the  marked  region  to  that file, and then
Z      transfers all text in the old version to the  new  version.   If
Z      the specified file does not exist, the command is ignored.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z      7.8  $XR -- Replace a given string
Z
Z
Z           The $XR command prompts for a string, and  it  replacement.
Z      Then,  from  the  current  pointer  position  to  the end of the
Z      buffer, the string is replaced.  The pointer is left  after  the
Z      last replacement made, if any.
Z
Z
Z
ZESCAPE X COMMANDS                                                       Page 7-3
Z
Z
Z
Z
Z      7.9  $XS -- Save EMACS11 macro in file
Z
Z
Z           The $XS command saves the current EMACS11 macro buffer con-
Z      tents in the specified file.
Z
Z
Z
Z      7.10  $XT -- Insert system time
Z
Z
Z           The $XT command inserts the current system  time  into  the
Z      text  buffer in the format HH:MM:SS, where HH is in the range of
Z      0-23, and both MM and SS are in the range of 0-59.
Z
Z
Z
Z      7.11  $XW -- Write marked region to file
Z
Z
Z           The $XW command opens a new file with the specified  files-
Z      pec  and  then  writes out the marked region to it.  The file is
Z      then closed.  This is done independently of  any  other  primary
Z      input or primary output files which may be open.
Z
Z
Z                        *** NOT YET IMPLEMENTED ***
Z
Z
Z
Z
Z
Z
Z                                   CHAPTER 8
Z
Z                                COMMAND SUMMARY
Z
Z
Z
Z      This chapter contains a summary, by  logical  function,  of  all
Z      commands.
ZCOMMAND SUMMARY                                                         Page 8-2
Z
Z
Z
Z
Z                           Pointer movement cmds:
Z                           ---------------------
Z       
Z       
Z        ^A    =>   Go to beginning of current line.
Z       
Z        ^B    =>   Go back one character.
Z       
Z        ^E    =>   Go to end of line.
Z       
Z        ^F    =>   Go forward one character.
Z       
Z        ^N    =>   Go to same place in next line.
Z       
Z        ^P    =>   Go to same place in previous line.
Z       
Z        ^V    =>   Move window down.
Z       
Z        $A    =>   Go backward to start of sentence.
Z                   [Not yet implemented]
Z       
Z        $B    =>   Go back one word.
Z       
Z        $E    =>   Go forward to start of next sentence.
Z                   [Not yet implemented]
Z       
Z        $F    =>   Go forward one word.
Z       
Z        $G    =>   Go to specified line number in current
Z                   buffer.  (precede command with line number
Z                   as $<digits>)
Z       
Z        $V    =>   Move window up.
Z       
Z        $[    =>   Go to beginning of paragraph.
Z                   [Not yet implemented]
Z       
Z        $]    =>   Go to end of paragraph.
Z                   [Not yet implemented]
Z       
Z        $<    =>   Go to beginning of buffer.
Z       
Z        $>    =>   Go to end of buffer.
Z       
Z        ^X^X  =>   Exchange mark and pointer
Z       
Z        ^X=   =>   Displays information about current position in
Z                   buffer.
ZCOMMAND SUMMARY                                                         Page 8-3
Z
Z
Z
Z
Z                            Buffer page commands
Z                            --------------------
Z       
Z       
Z        $N    =>   Write current buffer to output file, clear
Z                   buffer, and read in next page from input file.
Z       
Z        ^XA   =>   Append next page to buffer. Inserts form
Z                   feed if last read found a form feed.
Z       
Z        ^X^N  =>   Write all text in buffer above the current
Z                   window to the output file and read in next
Z                   page from input file.  (Useful for editing
Z                   near page boundries.)
Z       
Z        ^XN   =>   Same as ^X ^N but does not read in next
Z                   page.  Useful for making some room in the
Z                   buffer.
ZCOMMAND SUMMARY                                                         Page 8-4
Z
Z
Z
Z
Z                              Search commands:
Z                              ----------------
Z       
Z       
Z        ^S    =>   Incremental forward search.  Searches for
Z                   string as each character is input.  Can only
Z                   be exited with:
Z       
Z                     (1) An escape to signify stay at current
Z                     location after string found.
Z       
Z                     (2) ^G to abort and return to original
Z                     location.
Z       
Z                   Notes:
Z       
Z                     1. "DELETE" removes characters from
Z                     search string.
Z                     2.  When search string is null (empty) a 2nd
Z                     ^S within a search operation uses the most
Z                     recent successful search string.
Z                     3.  A 2nd ^S  at any other time within a
Z                     search operation finds the next occurance of
Z                     the current search string.
Z       
Z        ^R    =>   Incremental reverse search.  Same as ^S
Z                   except search progresses backwards.  Leaves
Z                   pointer at beginning of string found.
Z       
Z                   [Not yet implemented]
Z       
Z       
Z                   containing a specified string.
ZCOMMAND SUMMARY                                                         Page 8-5
Z
Z
Z
Z
Z                         Kill and delete commands:
Z                         -------------------------
Z
Z           Kill operations either initialize the kill buffer with  the
Z      removed  text,  or  append  the removed text to the current kill
Z      buffer contents, depending upon whether or not the  pointer  has
Z      moved  since the last kill operation.  (appends if hasn't moved)
Z      Delete operations remove the affected text and discard it.
Z       
Z        ^D    =>   Delete next character.
Z       
Z        ^K    =>   Kill to end of line / kill line
Z                   terminator.
Z       
Z        ^W    =>   Kill marked region.
Z       
Z        ^Y    =>   Yank back last kill.  (insert text stored
Z                   in kill buffer)
Z       
Z        $D    =>   Delete next word.   [Not yet implemented]
Z       
Z        $K    =>   Kill to end of sentence.
Z                   [Not yet implemented]
Z       
Z        $W    =>   Copy region between mark and pointer to
Z                   kill buffer, superceding existing text.
Z       
Z        $Y    =>   If used immediately after ^Y replaces
Z                   the text just "unkilled" with the text
Z                   that was the 2nd most recent victim.
Z                   [Not yet implemented]
Z       
Z        $^Y   =>   Yanks (pulls) last defined TECO command
Z                   into text buffer.
Z       
Z        $^W   =>   Append next kill to text already in kill
Z                   buffer (if any).  This command is nullified
Z                   by any pointer movement or text insertion.
Z       
Z        ^X^O  =>   Delete blank lines from current pointer to
Z                   next non-blank line.
Z                   [Not yet implemented]
Z       
Z        ^X    =>   Kill backwards to start of sentence.
Z                   [Not yet implemented]
Z       
Z        "DELETE" =>  Delete character before pointer.
Z          KEY
ZCOMMAND SUMMARY                                                         Page 8-6
Z
Z
Z
Z
Z                             TECO related cmds:
Z                             ------------------
Z       
Z       
Z        $$    =>   Enter TECO commands.  Terminate with
Z                   double $ or abort with ^G.
Z       
Z        MI$$  =>   Restart EMACS from TECO level.
Z       
Z        $^Y   =>   Insert last defined TECO command into
Z       
Z        $Z    =>   Return to TECO level. (can restart
Z                   EMACS with MI$$
Z       
Z        $*    =>   View last TECO command
Z       
Z        ^X$   =>   Re-execute TECO command most recently entered
Z                   with $$ command.
Z       
ZCOMMAND SUMMARY                                                         Page 8-7
Z
Z
Z
Z
Z                            Miscellaneous cmds:
Z                            -------------------
Z       
Z        ^C    =>   Return to TECO level.  (can restart EMACS
Z                   with MI$$)
Z       
Z        ^G    =>   *** THIS IS THE PANIC BUTTON ***
Z                   Gets you out of almost anything as long as
Z                   EMACS is not "hung".
Z       
Z        ^O    =>   Open blank line for insertion.
Z       
Z        ^Q    =>   Use next character as text.  (inserts cmds
Z                   as text)
Z       
Z        $S    =>   Center text in current line.  Uses a default
Z                   of 80 characters per line or can be preceded
Z                   with an argument of form $<digits> which
Z                   defines number of characters in line.
Z                   [Not yet implemented]
Z       
Z        $T    =>   Exchange words before and after pointer
Z                   (does nothing if pointer is inside a word).
Z                   [Not yet implemented]
Z       
Z        $%    =>   "Query replace" --- Prompt for search string
Z                    and its replacement, then from current
Z                    pointer to end of file, find string and query
Z                    user as follows:
Z                   (1) Space bar: go ahead and replace this
Z                       occurance.
Z                   (3) Any other key: don't replace, find next.
Z       
Z        ^XI   =>   Insert file at current pointer position.
Z                   First executes a ^X^N to make room in the
Z                   [Not yet implemented]
Z       
Z        $XC   =>   Enter/exit "see-all" mode (shows ALL char
Z                   in a file, even non-printing ones, with
Z                   special graphics)
Z       
Z        $XD   =>   Insert current date in text buffer in form
Z                   MM-DD-YR
Z       
Z        $XR   =>   "Replace" --- Prompt for search string and
Z                   its replacement, then from current pointer
Z                   to end of buffer, replace all occurances.
Z       
ZCOMMAND SUMMARY                                                         Page 8-8
Z
Z
Z
Z
Z                        Miscellaneous cmds (CONT.):
Z                        ---------------------------
Z       
Z       
Z        $XT   =>   Insert current time in text buffer in form
Z                   HH:MM:SS
Z       
Z        ^_    =>   "Help on tap" --- Interactive help processor.
Z                   [Not yet implemented]
Z       
Z        $?    =>   "Describe" --- Describe function of next
Z                   command without executing it.
Z                   [Not yet implemented]
ZCOMMAND SUMMARY                                                         Page 8-9
Z
Z
Z
Z
Z                           File related commands:
Z                           ----------------------
Z       
Z       
Z        ^X^R   =>   "Read file"   Reads in first page of a
Z                    given file after closing the currently
Z       
Z        ^X^S   =>   "Save file"   Writes buffer and rest of
Z                    currently open input file to currently
Z                    open output file, closes and reopens
Z                    file, and reads first page back in.
Z       
Z        ^X^V   =>   "Visit file"  Opens a given file for
Z                    both input and output after closing
Z                    the currently open output file (if any).
Z       
Z        ^X^W   =>   "Write file"  Sets output file to that
Z                    specified, after closing any currently
Z                    open output file (if any).
Z       
Z        ^Z^F   =>   "Get file name"  Insert most recently
Z                    specified output filename into text
Z                    buffer.
Z       
Z        ^Z^Z   =>   "Close files and exit"   Close all
Z                    files and exit EMACS.
ZCOMMAND SUMMARY                                                        Page 8-10
Z
Z
Z
Z
Z                            Keyboard macro cmds:
Z                            --------------------
Z       
Z       
Z        ^X(    =>   Start EMACS macro collection.
Z       
Z        ^X)    =>   Terminate EMACS macro collection.
Z       
Z        ^X*    =>   "View last macro" --- Clears screen
Z                    and displays last defined EMACS macro.
Z                    Pressing any key returns to edit mode.
Z                    Note some "commands" such as CRLF
Z                    are displayed in image mode.  This is
Z                    built into TECO.
Z       
Z        ^XT    =>   "Toggle update" --- Forces screen update
Z                    at current command inside a macro.  Useful
Z                    for verifying macro is executing properly
Z                    by viewing results at specific
Z                    points, buts slows down execution
Z                    considerably.
Z       
Z        ^XE    =>   Execute most recently collected EMACS macro.
Z       
Z        ^XQ    =>   When used inside a macro halts execution
Z                    and waits for
Z              
Z                    (1) press space bar to continue with
Z                    (2) use ^G to abort this macro and all
Z                        macro repeats pending.
Z                    (3) press any other key to exit current
Z                        macro, without effecting any pending
Z                        macro repeats.
Z       
Z        $XS    =>   "Save macro" --- Saves current EMACS macro
Z                    in a specified file.  Prompts for file name.
Z                    [Not yet implemented]
Z       
Z        $XL    =>   "Load macro" --- Loads EMACS macro from a
Z                    specified file.   Prompts for file name.
Z                    [Not yet implemented]
Z       
ZCOMMAND SUMMARY                                                        Page 8-11
Z
Z
Z
Z
Z                        The "mark" and region cmds:
Z                        ---------------------------
Z       
Z       
Z        $H     =>   Mark paragraph.  Puts mark at beginning of
Z                    paragraph, pointer at end.
Z                    [Not yet implemented]
Z       
Z        ^X^P   =>   Mark page ---  Put mark at top of page,
Z                    defined to be immediately after first form
Z                    feed backwards from current pointer, or top
Z                    of buffer, whichever is first.
Z                    Put pointer at bottom of page, defined to
Z                    be immediately after next form feed forwards
Z                    from current pointer, or bottom of buffer,
Z                    whichever is first.
Z                    [Not yet implemented]
Z       
Z        ^X^X   =>   Exchange mark and pointer; useful to verify
Z                    where current region is.
Z       
Z        $@     =>   Set mark at current pointer (is EMACS ^@).
Z       
Z        $XA    =>   Append currently defined region to an
Z                    existing file. Prompts for file name.
Z                    [Not yet implemented]
Z       
Z        $XP    =>   Prepend currently defined region to an
Z                    existing file.  Prompts for file name.
Z                    [Not yet implemented]
Z       
Z        $XW    =>   Write currently defined region to a new
Z                    file.  Prompts for file name.
Z                    [Not yet implemented]
Z       
ZCOMMAND SUMMARY                                                        Page 8-12
Z
Z
Z
Z
Z                           Case conversion cmds:
Z                           ---------------------
Z       
Z       
Z         $C    =>   Capitalize next word.
Z                    [Not yet implemented]
Z       
Z         $L    =>   Lower case next word.
Z                    [Not yet implemented]
Z       
Z         $U    =>   Upper case next word.
Z                    [Not yet implemented]
Z       
Z         ^X^L  =>   Lower case marked region.
Z       
Z         ^X^U  =>   Upper case marked region.
ZCOMMAND SUMMARY                                                        Page 8-13
Z
Z
Z
Z
Z                                Misc. notes:
Z                                ------------
Z
Z      1.  Most commands can be preceded with a  repeat  count  of  the
Z          form  $<digits>.  Even "commands" which are self-insertions,
Z          I.E.  $20H inserts 20 "H"s in text buffer.
Z
Z      2.  Commands which "view information" (such as $ X O  or  ^X  =)
Z          wait  for  the  user  to  press  any key and then return the
Z          screen to its normal window mode into the text buffer.   The
Z          character  input by the single key stroke is discarded.  The
Z          text buffer is not affected by the view operation.
STUNKYFLUFF
set `sum emacs.doc`
if test 43879 != $1
then
echo emacs.doc: Checksum error. Is: $1, should be: 43879.
fi
#
#
echo Extracting emacs.src:
sed 's/^Z//' >emacs.src <<\STUNKYFLUFF
Z	EMACS.SRC	---	EMACS command compatable editor for	
Z				PDP-11 and VAX systems which have
Z				TECO, version 35 or later.
Z
Z	Written by:		Fred Fish
Z
Z        Last modified:		16:41:18 06-17-82 by Fred Fish
Z									
Z
Z	Q register usage:						
Z									
Z		Note:	For each Q register number there are TWO	
Z			storage areas, one for numeric data and one for 
Z			text.  They are refered to here as QnN and	
Z			QnT respectively, where "n" is the Q register	
Z			number.						
Z									
Z			In general, low alphabetic Q registers are	
Z			used for local storage and high alphabetic	
Z			Q registers are used for global storage and	
Z			macros.						
Z									
Z									
Z		QMN  =>	Marked location pointer.  Contains numeric 	
Z			  pointer to last character location at which	
Z			  a mark was set.				
Z									
Z		QNN  =>	Current pointer save.				
Z									
Z		QON  =>	Repeat count.  For commands which support using	
Z			  a repeat count preceding the command of the	
Z			  form <ESC><digits>, the count is stored in	
Z			  this register.				
Z									
Z		QQN  => Abort back to highest level if set to 0		
Z									
Z		QWN  =>	Last column number of a ^N or ^P command
Z
Z		QTN  =>	Current command character ascii value		
Z									
Z		QXN  => Macro repeat count				
Z									
Z		QYN  => Emacs macro command fetch down counter		
Z									
Z		QZN  =>	Control flags word				
Z									
Z		QHT  => Macro to move cursor to a given line,
Z			erase that line, leave cursor at beginning
Z			of that line, and make TECO forget it did
Z			anything to screen.
Z
Z		QIT  => Contains most of the run time macros which
Z			make up the specific commands for EMACS.
Z			Overwrite this and you've wiped out the
Z			editor!
Z
Z		QKT  =>	Primary input file full file-spec
Z
Z		QLT  =>	Search prompt.					
Z									
Z		QMT  =>	Contains terminal image mode macro.		
Z									
Z		QNT  =>	Contains string input macro			
Z									
Z		QOT  =>	Editor status line update macro
Z
Z		QPT  => Macro to get next character from terminal	
Z									
Z		QQT  =>	TECO command minibuffer. 			
Z									
Z		QRT  =>	Macro to find screen line number as num arg	
Z									
Z		QST  =>	String fetched by prompt/string input macro	
Z									
Z		QTT  =>	Output filespec for currently open output file	
Z									
Z		QUT  =>	Macro to allow option of saving modified 	
Z			buffer when no output file is open.		
Z									
Z		QVT  => Last successful EMACS search string		
Z									
Z		QWT  =>	Emacs macro command string			
Z									
Z		QXT  => Macro to fetch next command from terminal	
Z			stream or EMACS macro stream (calls QPT macro)	
Z									
Z		QYT  =>	Kill buffer 2 (contains next most recent kill)	
Z									
Z		QZT  =>	Kill buffer 1 (contains most recent kill)	
Z									
Z	LABEL POINTS:							
Z									
Z		A   =>							
Z									
Z		B   =>							
Z									
Z		F   =>							
Z									
Z		M   =>	^N and ^P common processing point.		
Z									
Z		QR  =>	Query replace / replace common processing	
Z									
Z		S   =>	Search execution start point			
Z									
Z		X   =>	Start point for ^X macros.			
Z									
Z		$   =>	Start point for ESC- macros.			
Z									
Z		$X  =>  Start point for ESC-X- macros.			
Z									
Z	Editor status word (QZN) bits:					
Z	Meaning if bit set						
Z									
Z		  32   =>	Enable macro collection			
Z									
Z		  16   =>	Inhibit screen update during cmd input	
Z									
Z		   8   =>	Primary output stream file is open	
Z									
Z		   4   =>	Primary input stream file is open	
Z									
Z		   2   =>	Current primary file has been modified	
Z									
Z		   1   =>	Append next kill to kill buffer 1	
Z
Z!* START !
Z
ZEI			!*Close off the input file			!
ZHK			!*Purge the buffer				!
ZGZ			!*Pull in the command line from QZT		!
ZJ			!*Jump back to beginning			!
Z^D
Z128,0ET			!*Reset abort on error bit			!
Z-1,5:W			!*Set terminal to hold whole screen		!
Z^[			!*Discard numeric argument returned by :W cmd	!
Z22,2:W			!*Protect the bottom 2 status lines from update	!
Z^[			!*Discard numeric argument returned by :W cmd	!
Z
Z!* Preload QHT with macro to erase a given line on screen, leave cursor	!
Z!* at that line, and make TECO forget it did anything to the terminal.	!
Z
Z@^UH~			!* QHT <= macro between the "~" s		!
Z  [A			!* Push QAT and QAN onto Q register stack	!
Z  UA			!* QAN <= input line number			!
Z  0,1ET			!* Enable image mode output			!
Z  27^T			!* Send escape to terminal			!
Z  ^^[^T
ZQA\
Z^YT
Z^YK
Z^^H^T
Z  1,0ET			!* Disable image mode output			!
Z  ^^KMM			!* Kill the current lines contents		!
Z  32768W		!* Make TECO forget we messed with screen	!
Z  ]A			!* Pop QAT and QAN off the Q register stack	!
Z~			!* End of macro load into QHT			!
Z
Z!*Preload QMT with macro to output characters to terminal in image mode !
Z!*Q registers affected by an MM:  QAN					!
Z
Z@^UM~			!*QMT <= macro between "~" s  			!
Z  UA			!*QAN <= macro's argument (char to output) 	!
Z  0,1ET			!*Set image mode bit				!
Z  27^T			!*Send ESC to terminal for special sequence	!
Z^^[^T
Z  QA^T			!*Send the saved character to terminal		!
Z  1,0ET			!*Reset back to non image mode			!
Z~			!*End of image mode macro load in QMT		!
Z
Z!*Preload QUT with macro to optionally save a modified buffer		!
Z!*Q register affected by MU:  QLT, QAN, QST, QAN, QTN, QQN, QYN, QXN,	!
Z!*QWT									!
Z
Z@^UU~			!*QUT <= all characters between the "~" s	!
Z  <			!*Begin loop to save buffer			!
Z    @^UL%Save%		!*QLT <= "Save"					!
Z    @32:^UL%%		!*QLT <= "Save "				!
Z    @:^UL%modified%	!*QLT <= "Save modified"			!
Z    @32:^UL%%		!*QLT <= "Save modified "			!
Z    @:^UL%buffer%	!*QLT <= "Save modified buffer?"		!
Z    @32:^UL%%		!*QLT <= "Save modified buffer? "		!
Z    @:^UL%(Y/N)%	!*QLT <= "Save modified buffer? (Y/N)"		!
Z    MN			!*Get response from user			!
Z    UA			!*Save returned success/abort code		!
Z    QA;			!*Abort function if string fetch failed		!
Z    GS			!*Get the response string			!
Z    -1A-^^N"E		!*If response is "N" then			!
Z      -1UA		!*QAN <= code for successful execution		!
Z      HK		!*Purge the current buffer			!
Z      0;		!*Abort iteration and go to terminal code	!
Z    '			!*End of "N" processing				!
Z    -1A-^^Y"E		!*If response is "Y" then			!
Z      ^YK		!*Delete response from text buffer		!
Z      @^UL%File:%	!*QLT <= "File:"				!
Z      @32:^UL%%		!*QLT <= "File: "				!
Z      MN		!*Get response from user			!
Z      UA		!*Save returned success/abort code		!
Z      QA;		!*Abort function if string fetch failed		!
Z      @^UA%@EW/%	!*QAT <= "@EW/"					!
Z      GS		!*Pull file name string into buffer		!
Z      ^Y:XA		!*QAT <= "@EW/<filename>"			!
Z      ^YK		!*Delete from buffer in case we bomb		!
Z      @:^UA%/%		!*QAT <= "@EW/<filename>/"			!
Z      MA		!*Open the file to save current buffer in	!
Z      EC		!*Write out buffer and close file		!
Z      HK		!*Purge the buffer				!
Z      0;		!*Abort iteration and go to terminal code	!
Z    '			!*End of "Y" processing				!
Z    ^YK			!*Delete previous response from text buffer	!
Z  >			!*End loop to save buffer			!
ZQA			!*Return success code				!
Z~
Z
Z!*Preload QPT with macro to get next char from terminal stream		!
Z!*Q registers affected by MP: QTN, QYN, QXN, QQN			!
Z
Z@^UP~			!*QPT <= everything between "~" s		!
Z  0,32ET		!*Set read with no wait for pending commands	!
Z  ^TUT			!*QTN <= next pending command (-1 if none)	!
Z  QT"L			!*If no pending commands then			!
Z    32,0ET		!*Reset read with no wait bit to get user input	!
Z    16&QZ"E		!*If screen update is not inhibited then	!
Z      -1W		!*Update the terminal screen			!
Z    '			!*End of screen update test			!
Z    ^TUT		!*QTN <= next command from user			!
Z  '			!*End of no pending commands execution		!
Z  QT-7"E		!*If input from terminal is a ^G then		!
Z    0UY			!*Reset counter to exit current macro		!
Z    0UX			!*Reset counter to exit pending macros		!
Z    0UQ			!*Reset word to cause abort to highest level	!
Z  '			!*End of ^G from terminal processing		!
Z  QQ			!*Return ^G abort code as numerical argument	!
Z~			!*End of QPT macro load				!
Z
Z!* Preload QOT with macro to update editor status line (line 23)	!
Z
Z@^UO~			!* QOT <= all characters between the "~" s	!
Z  23MH			!* Go ready the editor status line		!
Z  @^A%EMACS%		!* First entry on editor status line		!
Z  32^T			!* Send blank to terminal			!
Z  @^A%Ver%		!* Second entry on editor status line		!
Z  32^T			!* Send blank to terminal			!
Z  @^A%1.4%		!* Third entry on editor status line		!
Z  32^T			!* Send blank to terminal			!
Z  32^T			!* Send blank to terminal			!
Z  QZ&32"N		!* If LEARN mode is enabled then		!
Z    @^A%(Learn)%	!* Show learn prompt				!
Z  |			!* Else if not learn mode			!
Z    @^A%(Fundamental)%	!* Show fundamental mode			!
Z  '			!* End of mode entry on status line		!
Z  32^T			!* Send blank to terminal			!
Z  32^T			!* Send blank to terminal			!
Z  12&QZ"N		!* If a primary file is open then		!
Z    32^T		!* Send another blank to terminal		!
Z    @^A%File:%		!* Filespec is last entry on status line	!
Z    8&QZ"N		!* If primary output file stream is open then	!
Z      :GT		!* Get the output file spec			!
Z    |			!* Else input file must be open			!
Z      :GK		!* Get input file spec				!
Z    '			!* End of file spec test			!
Z  '			!* End of filespec insertion			!
Z  32768W		!* Forget we did anything to screen		!
Z~			!* End of status line update macro		!
Z
Z!*Preload QXT with macro to fetch next command character		!
Z!*Q registers affected by MX:  QTN, QYN, QXN, QQN, QWT,			!
Z
Z@^UX~			!*QXT <= all characters between the "~" s	!
Z  QY"E			!*If no EMACS macro commands to execute then	!
Z    MP			!*Get next command from command stream		!
Z    32&QZ"N		!*If learn mode is enabled then 		!
Z      @QT:^UW%%		!*Append the command to the macro buffer	!
Z    '			!*End of macro collection test			!
Z  '			!*End of no EMACS macro commands execution	!
Z  QY"L			!*If EMACS macro commands to execute then	!
Z    GW			!*Pull macro commands into buffer		!
Z    QYAUT		!*QTN <= EMACS command extracted from string	!
Z    ^YK			!*Kill string in buffer				!
Z    %Y			!*Increment macro command counter		!
Z    "E			!*If was last EMACS macro command then		!
Z      %X		!*Increment macro repeat counter		!
Z      "L		!*If more repeat loops to be done then		!
Z        -:QWUY		!*Restore command counter contents		!
Z      '			!*End of macro command counter restore		!
Z    '			!*End of last repeat loop test			!
Z  '			!*End of EMACS macro command fetch		!
Z  QQ			!*Return abort code as argument			!
Z~			!*End of QXT macro load				!
Z
Z!*Preload QNT with macro to input strings 				!
Z!*Q registers affected by MN: QST, QAN, QTN, QQN, QYN, QXN, QWT		!
Z
Z@^UN~			!*QNT <=  All characters between the "~" s	!
Z  0,0XS			!*QST <= null string (clear it)			!
Z  24MH			!*Go ready the prompt line			!
Z  :GL			!*Display prompt in QLT on terminal		!
Z  16#QZUZ		!*Set screen update inhibit bit			!
Z  -1UA			!*QAN <= no exit on esc value			!
Z  <			!*Begin infinite iteration to input string	!
Z    MX			!*QTN <= next character from command stream	!
Z    ;			!*If input was a ^G then abort function		!
Z    QT-10"N		!*If input was not line feed then		!
Z      QT^T		!*Echo character to terminal 			!
Z    '			!*End of scroll producing character trap	!
Z    @QT:^US%%		!*Append input character to QST string		!
Z    QT-10"E		!*If input was LF character then		!
Z      0;		!*Exit the input iteration			!
Z    '			!*End of LF execution 				!
Z    QT-127"E		!*If input was a "DELETE" character		!
Z      GS		!*Pull string into text buffer			!
Z      ^Y-1XS		!*Push back into QST minus "DELETE" character	!
Z      :QS"N		!*If not all characters deleted			!
Z        ^Y-2XS		!*Push back string minus char and "DELETE"	!
Z      '			!*End of non-null string character delete	!
Z      ^YK		!*Delete from text buffer			!
Z      24MH		!*Erase old prompt string			!
Z      :GL		!*Display prompt string				!
Z      :GS		!*Display current input string			!
Z      -1UA		!*QAN <= no double esc flag			!
Z      F<		!*Go get the next input				!
Z    '			!*End of DELETE character processing		!
Z    QT-27"E		!*If input was an ESC character then		!
Z      QA;		!*Exit input iteration if double ESC set	!
Z      0UA		!*Set to cause exit on next ESC			!
Z      F<		!*Go get the next input				!
Z    '			!*End of ESC input processing			!
Z    -1UA		!*QAN <= no double esc flag			!
Z  >			!*End of infinite iteration to input characters	!
Z  24MH			!*Erase the prompt line				!
Z  QQ"S			!*If successful string fetch then		!
Z    GS			!*Pull final string into text buffer		!
Z    ^Y-2XS		!*Strip off $$ or CRLF terminator		!
Z    ^YK			!*Delete from text buffer			!
Z  '			!*End of terminator removal			!
Z  16^_&QZUZ		!*Reset screen update inhibit bit		!
Z  QQ			!*Return success or failure code		!
Z~			!*End of string input macro			!
Z
Z!*LOAD TEXT Q REGISTER I WITH INFINITE ITERATION WHICH IS THE "ROOT"	!
Z!*OF THE EXECUTION COMMANDS						!
Z
Z@^UI~			!*QUI <= main editor macro between "~" char	!
Z  ^D			!*Set numeric radix to decimal			!
Z  225,30ET		!*No abort; attached; wait; not-image mode	!
Z			!*Cancel ^O; no-echo, lower-case; scope		!
Z  16ED			!*Yank prot; ^ means ctrl; srch	fail anchor	!
Z  16^_&QZUZ		!*Insure terminal update inhibit bit gets reset	!
Z  ^^HMM			!*Send cursor home				!
Z  ^^JMM			!*Clear entire screen				!
Z  MO			!*Update the status line			!
Z  32^T			!*Force TECO to update screen on next -1W cmd	!
Z  <			!*Begin edit execution macro 			!
Z    !A!			!*Label point 					!
Z    0UW			!*QWN <= 0 (Initialize up/down line loc save)	!
Z    !B!			!*Label point 					!
Z    -1UQ		!*QQN <= success  (reset abort value)		!
Z    1UO			!*QO <= 1 (Initialize repeat count) 		!
Z    16^_&QZUZ		!*Reset screen update inhibit bit		!
Z    MX			!*Get the next EMACS command			!
Z
Z!*BEGIN EXECUTION OF THE CURRENT COMMAND 				!
Z
Z    !V!			!*Start execution of command 			!
Z 
Z    QT-8"E		!*FOR VAX					!
Z      24UT		!*MAP ^H to ^X					!
Z    '
Z
Z    QT-20"E		!*FOR VAX					!
Z      19UT		!*MAP ^T to ^S					!
Z    '
Z
Z    QT-21"E		!*FOR VAX					!
Z      25UT		!*MAP ^U to ^Y					!
Z    '
Z
Z    QT@O/AI,CA,CB,CC,CD,CE,CF,CG,AI,AI,AI,CK,CL,AI,CN,CO,CP,CQ,CR,CS/
Z    QT-20@O/AI,AI,CV,CW,CX,CY,CZ,$/
Z
Z    QT-127"E		!*If command is a "delete" character then 	!
Z      QO<		!*Do by number of repeat counts			!
Z        -.;		!*Abort iteration if at buffer beginning	!
Z        -D		!*Delete back one character			!
Z      >			!*End of repeat iteration			!
Z      1^_&QZ#2UZ	!*No kill append; buffer modified		!
Z      F<		!**** Go get another user command 		!
Z    '			!*End of "delete" char execution 		!
Z
Z    !AI!		!*Auto insert the cmd char as text		!
Z    QO<QT@I%%>		!*Do an auto insert				!
Z    1^_&QZ#2UZ		!*No kill append; buffer modified		!
Z    F<			!**** Go get next command			!
Z
Z    !CA!		!*Begin ^A execution				!
Z    0L			!*Set pointer to beginning of current line	!
Z    1^_&QZUZ		!*No kill append;				!
Z    F<			!**** Go get another user command 		!
Z
Z    !CB!		!*Begin ^B execution				!
Z    QO<			!*Repeat by repeat count			!
Z      -.;		!*Exit iteration if at buffer beginning		!
Z      R			!*Backup one character				!
Z      >			!*End of repeat iteration			!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get another user command 		!
Z
Z    !CC!		!*Begin ^C execution				!
Z      0;		!*Return to teco level (can restart with MI) 	!
Z
Z    !CD!		!*Begin ^D execution				!
Z    QO<			!*Repeat by repeat count in QON			!
Z      .-Z;		!*Exit iteration if at buffer end		!
Z      D			!*Delete one character				!
Z    >			!*End of iteration				!
Z    1^_&QZ#2UZ		!*No kill append; buffer modified		!
Z    F<			!**** Go get next user command 			!
Z
Z    !CE!		!*Begin ^E execution				!
Z    L			!*Go to end of current line 			!
Z    ."N			!*If not at beginning of buffer then		!
Z      -1A-10"E		!*If previous character is a LF then		!
Z        2R		!*Back up over CRLF characters			!
Z      '			!*End of CRLF backover operation		!
Z    '			!*End of buffer beginning check			!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get next user command			!
Z 
Z    !CF!		!*Begin ^F execution				!
Z    QO<			!*Do by repeat count				!
Z      .-Z;		!*Exit iteration if at buffer end		!
Z      C			!*Go forward one character			!
Z    >			!*End of iteration				!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get next user command 			!
Z   
Z    !CG!		!*Begin ^G execution				!
Z    0UX			!*Abort any pending macro repeats		!
Z    0UY			!*Abort any pending commands in a current macro	!
Z    16#32^_&QZUZ	!*Reset screen inhibit and macro collection bits!
Z    7MM			!*Ring terminal's bell (no dirty thoughts now!)	!
Z    MO			!*Refresh status line				!
Z    F<			!**** Go get next user command			!
Z
Z    !CK!		!*Begin ^K execution				!
Z    QO<			!*Do the number of kills specified by repeat	!
Z      .-Z;		!*If at end of buffer then exit kill		!
Z      0AUA		!*QAN <= ascii code of next char in buffer	!
Z      QA-13"E		!*If it is a CR then kill the CRLF only		!
Z        QZ&1"N		!*If append bit is set then append kill 	!
Z          .,.+2:XZ	!*Append CRLF to kill buffer 1			!
Z        |		!*Else if append bit is not set then		!
Z          GZ		!*Pull kill buffer 1 contents into text buffer	!
Z          ^YXY		!*QTY <= second most recent kill		!
Z          ^YK		!*Delete second most recent kill from text buffr!
Z          .,.+2XZ	!*QTZ <= CRLF from end of line			!
Z          QZ#1UZ	!*Set the append bit for further kills		!
Z        '		!*End of CRLF kill in non-append mode		!
Z        2D		!*Delete CRLF from buffer			!
Z      |			!*Else if not at end of line then		!
Z        .-Z;		!*Exit the kill command if at buffer end	!
Z        .UA		!*Save current pointer position 		!
Z        L		!*Go to end of current line (after CRLF)	!
Z        -.;		!*If at top of buffer then exit kill command	!
Z        -1A-10"E	!*If previous char is LF then			!
Z          2R		!*Back up over CRLF 				!
Z        '		!*End of backup check				!
Z        QZ&1"N		!*If append bit is set then append kill		!
Z          QA,.:XZ	!*Append kill to buffer 1			!
Z        |		!*Else if append bit is not set then		!
Z          GZ		!*Pull kill buffer 1 contents into text buffer	!
Z          ^YXY		!*QTY <= second most recent kill		!
Z          ^YK		!*Delete second most recent kill from text buffr!
Z          QA,.XZ	!*QTZ <= current line up to CRLF		!
Z          QZ#1UZ	!*Set the append bit for further kills		!
Z        '		!*End of non-EOL non-append			!
Z        QA,.K		!*Kill the line up to CRLF			!
Z      '			!*End of non-EOL kill				!
Z    >			!*End of kill iteration				!
Z    2#QZUZ		!*Set buffer modified bit			!
Z    F<			!**** Go get next command 			!
Z    
Z    !CL!		!*Begin ^L execution				!
Z    ^^HMM		!*Send cursor to home position			!
Z    ^^JMM		!*Erase the entire screen (including last lines)!
Z    0,5:W		!*Turn off hold mode temporarily		!
Z    ^[			!*Discard numeric argument returned by :W cmd	!
Z    -1W			!*Update the screen				!
Z    -1,5:W		!*Turn hold mode back on			!
Z    MO			!*Put status line back in			!
Z    F<			!**** Go get next command			!
Z
Z    !CN!		!*Begin ^N execution				!
Z    1UA			!*Set up for down one line 			!
Z    @O!M!		!**** Go do the move 				!
Z   
Z    !CO!		!*Begin ^O execution				!
Z    QO<			!*Repeat by count 				!
Z      13@I%%		!*Insert a CR character 			!
Z      10@I%%		!*Insert a LF character 			!
Z      2R		!*Back up over the CRLF 			!
Z    >			!*End of repeat loop 				!
Z    1^_&QZ#2UZ		!*No kill append; buffer modified		!
Z    F<			!**** Go get next command 			!
Z   
Z    !CP!		!*Begin ^P execution				!
Z    -1UA		!*Set up for UP one line 			!
Z    !M!			!*^N and ^P move start label point 		!
Z    QO*QAUO		!*QON <= Number of lines to jump		!
Z    QW"E		!*If position # unknown from previous then	!
Z      0UD		!*QD <= zero					!
Z      .UA		!*QA <= current pointer loc 			!
Z      0L		!*Go to beginning of current line 		!
Z      QA-.%W<		!*Repeat for # of char to original pointer loc	!
Z        0A-32"L		!*If next buffer char is not printable char 	!
Z          0A-27"N	!*If next buffer char is not ESC then 		!
Z            0A-9"E	!*If next bffer char is a tab then 		!
Z              6-(QD&7)%W^[	!*					!
Z              -2UD	!*						!
Z            '		!*						!
Z            %D		!*Increment char counter			!
Z            1%W		!*Increment char loc for the "^" char		!
Z          '		!*End of non-ESC test				!
Z        '		!*End of non-printable test			!
Z        C		!*Move over one character			!
Z        %D		!*Increment character counter			!
Z      >			!*End of char location in line computation	!
Z    '			!*End of unknown location processing		!
Z    QOL			!*Go to start of destination line		!
Z    -QWUC		!*Initialize pointer location counter		!
Z    0UD			!*Clear character counter			!
Z    QW<			!*Begin iteration to go to character location	!
Z      .-Z;		!*If reached end of buffer then exit iteration	!
Z      0A-32"L		!*If next char is non-printable char then	!
Z        0A-13"E		!*If next char is also a CR then		!
Z          0;		!*Exit iteration; reached end of line		!
Z        '		!*End of CR processing 				!
Z        0A-27"N		!*If next char is NOT an ESC then		!
Z          0A-9"E	!*If next char is a TAB then			!
Z            6-(QD&7)%C^[!*						!
Z            -2UD	!*						!
Z          '		!*						!
Z          %D		!*Increment character counter			!
Z          1%C		!*Increment location counter			!
Z        '		!*End of non-ESC non-printable char processing	!
Z      '			!*End of non-printable char processing		!
Z      C			!*Move over one character in line		!
Z      %D		!*Increment character counter			!
Z      1%C		!*Increment location counter			!
Z      "G		!*If we over ran the location then		!
Z        R		!*Backup one character				!
Z      '			!*End of over run correction			!
Z      QC;		!*If have reached location then exit iteration	!
Z    >			!*End of new line move iteration		!
Z    1^_&QZUZ		!*No kill append				!
Z    @O!B!		!**** Go get next command			!
Z 
Z    !CQ!		!*Begin ^Q execution				!
Z    MX			!*Get the next input character 			!
Z    ^[			!*Discard any returned numeric value		!
Z    QO<			!*Repeat by count 				!
Z      QT@I%%		!*Insert the character 				!
Z    >			!*End of repeat loop 				!
Z    1^_&QZ#2UZ		!*No append of next kill; buffer modified	!
Z    F<			!**** Go get next command 			!
Z
Z    !CS!		!*Begin ^R or ^S execution			!
Z    QT-18"E		!*If command is ^R then				!
Z      -QOUO		!*Reverse search count				!
Z    '			!*End of search count negation for ^R command	!
Z    .UE			!*QEN <= original  pointer position		!
Z    0,0XA		!*QAT <= null string (initialize search string)	!
Z    <			!*Begin infinite search iteration loop		!
Z      MX		!*Get next command from command stream		!
Z      ^[		!*Discard any returned numeric value		!
Z      QT-7"E		!*If command is ^G then				!
Z        QEJ		!*Jump back to original pointer location	!
Z        24MH		!*Flush the current prompt line			!
Z        0;		!*Exit the search iteration			!
Z      '			!*End of ^G processing inside ^S loop		!
Z      QT-18"E		!*If input char is a ^R then			!
Z        :QA"E		!*If search string is null then			!
Z          GV		!*Pull previous successful search string in	!
Z          ^YXA		!*QAT <= previous search string			!
Z          ^YK		!*Delete string from text buffer		!
Z          @O!S!		!*Go search for new string			!
Z        |		!*Else if string is not null then		!
Z          .UF		!*QFN <= last successful search pointer loc	!
Z          @O!S2!	!*Go do search but start from current location	!
Z        '		!*End of non-null ^R processing			!
Z      '			!*End of ^R processing inside ^S loop		!
Z      QT-19"E		!*If input char is a ^S then			!
Z        :QA"E		!*If search string is null then			!
Z          GV		!*Pull previous successful search string in	!
Z          ^YXA		!*QAT <= previous search string			!
Z          ^YK		!*Delete string from text buffer		!
Z          @O!S!		!*Go search for new string			!
Z        |		!*Else if string is not null then		!
Z          .UF		!*QFN <= last successful search pointer loc	!
Z          @O!S2!	!*Go do search but start from current location	!
Z        '		!*End of non-null ^S processing			!
Z      '			!*End of ^S processing inside ^S loop		!
Z      QT-27"E		!*If input char is ESC then			!
Z        0;		!*Exit search loop				!
Z      '			!*End of ESC processing inside ^S loop		!
Z      QT-127"E		!*If  input is DELETE char then			!
Z        :QA"N		!*If search string is not null then		!
Z          GA		!*Pull string into text buffer			!
Z          ^Y-1XA	!*QAT <= truncated search string		!
Z          ^YK		!*Kill search string in text buffer		!
Z          24MH		!*Flush the current prompt line			!
Z        '		!*End of non-null DELETE processing		!
Z        @O!S!		!*Jump to search begin point			!
Z      '			!*End of DELETE char processing			!
Z      @QT:^UA%%		!*Append input character to QAT			!
Z      !S!		!*Search label point				!
Z      .UF		!*QFN <= last successful search pointer loc	!
Z      QEJ		!*Start search from original location		!
Z      !S2!		!*Label point for search starting from current	!
Z      16^_&QZUZ		!*Reset screen update inhibit bit		!
Z      QO:@S%^EQA%	!*Search for occurance specified by QON		!
Z      "U		!*If search was not successful then		!
Z        QFJ		!*Go back to last successful location		!
Z        24MH		!*Go ready the prompt line			!
Z        @^UB%Not%	!*QBT <= "Not"					!
Z        @32:^UB%%	!*QBT <= "Not "					!
Z        @:^UB%Found:%	!*QBT <= "Not Found:"				!
Z        @32:^UB%%	!*QBT <= "Not Found: "				!
Z        :GB		!*Show "Not Found: " to user			!
Z        :GA		!*Show search string to user			!
Z        32768W		!*Tell TECO to forget we messed with screen	!
Z        QY"N		!*If inside an EMACS macro then			!
Z          0UX		!*Flush macro repeat count to abort macros	!
Z          0UY		!*Abort any commands left in the current macro	!
Z          24MH		!*Flush the prompt line				!
Z          0;		!*Exit the search iteration			!
Z        |		!*Else if not inside macro			!
Z          16#QZUZ	!*Set terminal update inhibit bit		!
Z        '		!*End of EMACS macro test			!
Z      |			!*Else if the search was successful then	!
Z        QO"L		!*If search is reverse then			!
Z          .+^SJ		!*Jump to beginning of string			!
Z        '		!*End of reverse search pointer adjustment	!
Z        GA		!*Get the successful search string		!
Z        ^YXV		!*QVT <= most recent successful search string	!
Z        ^YK		!*Delete string from text buffer		!
Z        1^_&QZUZ	!*Reset append next kill bit			!
Z      '			!*End of search success test			!
Z    >			!*End of search loop				!
Z    16^_&QZUZ		!*Insure terminal update inhibit gets reset	!
Z    QE-."N		!*If final position is not same as initial then	!
Z      1^_&QZUZ		!*Reset append next kill bit			!    
Z    '			!*End of pointer movement test			!
Z    F<			!**** Go get next command			!
Z   
Z    !CV!		!*Begin ^V execution				!
Z    20*QOL		!*Jump down that many windows 			!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get next command 			!
Z   
Z    !CW!		!*Begin ^W execution				!
Z    QZ&1"N		!*If append mode then				!
Z      QM,.:XZ		!*Append the marked region to kill buffer 1	!
Z    '			!*End of append					!
Z    QZ&1"E		!*If non-append mode then			!
Z      GZ		!*Pull kill buffer 1 contents into text buffer	!
Z      ^YXY		!*QTY <= second most recent kill		!
Z      ^YK		!*Delete second most recent kill from text buffr!
Z      QM,.XZ		!*QZT <= Currently marked region		!
Z      QZ#1UZ		!*Set append bit in QNZ				!
Z    '			!*End of non append kill save			!
Z    QM,.K		!*Kill from last mark to current point		!
Z    2#QZUZ		!*Mark buffer modified				!
Z    F<			!**** Go get next command 			!
Z   
Z    !CY!		!*Begin ^Y execution				!
Z    :QZ"N		!*If kill buffer length is not zero then	!
Z      QO<GZ>		!*Get current kill buffer 1 contents		!
Z      1^_&QZ#2UZ	!*No append on next kill; buffer modified	!
Z    '			!*End of unkill operation			!
Z    F<			!**** Go get next command 			!
Z
Z
Z!*ESC COMMAND MACROS START HERE 					!
Z   
Z    !$!			!*Begin input of 2nd char in 2 char cmd		!
Z    MX			!*Get 2nd char from user 			!
Z   
Z    ^[			!*Discard any returned numeric value		!
Z
Z    QT-7"E		!*If command is an ESC-^G then			!
Z      F<		!**** Go get next command			!
Z    '			!*End off ESC-^G execution			!
Z
Z    QT"D		!*If input was a numeric arg then 		!
Z      0UO		!*QO  <= 0  (clear repeat count) 		!
Z      16#QZUZ		!*Set inhibit screen update during input bit	!
Z      -1UA		!*QAN <= -1 (no loop exit)			!
Z      <			!*Begin infinite numeric fetch loop 		!
Z        QA;		!*Exit when input was not digit			!
Z        QO*10+QT-^^0UO	!*Build numeric value 				!
Z        MX		!*Get next char 				!
Z        ^[		!*Discard any returned numeric value		!
Z        QT-7"E		!*If input is ^G then				!
Z          1UO		!*Reset repeat count to 1			!
Z          0;		!*Exit the iteration				!
Z        '		!*End of ^G trap				!
Z        0UA		!*Set up to cause loop exit			!
Z        QT"D		!*If was a digit in then 			!
Z          -1UA		!*Set up to stay in loop			!
Z        '		!*End of digit test				!
Z      >			!*End of infinite numeric loop 			!
Z      16^_&QZUZ		!*Reset inhibit screen update during input bit	!
Z      @O!V!		!**** Go execute next command 			!
Z    '			!*End of numeric arg input 			!
Z   
Z    QT"V		!*If 2nd char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-^^X"E		!*If command is an ESC-X- command then		!
Z      @O!$X!		!**** Go to ESC-X macros			!
Z    '			!*End of ESC-X test				!
Z  	 
Z    QT-23"E		!*If command is ESC-^W then			!
Z      1#QZUZ		!*Append next kill to kill buffer		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-^W execution			!
Z
Z    QT-25"E		!*If command is ESC ^Y then			!
Z      G9		!*Yank in the TECO minibuffer contents		!
Z      1^_&QZ#2UZ	!*No append next kill; buffer modified		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC ^Y execution			!
Z
Z    QT-27"E		!*If command is ESC-ESC then 			!
Z      @^UL%Command:%	!*QLT <= Minibuffer prompt 			!
Z      @32:^UL%%		!*QLT <= "Command: "				!
Z      MN		!*Get input string from user			!
Z      "U		!*If string fetch was unsuccessful then 	!
Z        32768W		!*Tell TECO to forget we fiddled with screen	!
Z        F<		!**** Go get next command			!
Z      '			!*End of fetch failed test			!
Z      GS		!*Pull string into buffer			!
Z      ^YXQ		!*Push string into QQT				!
Z      ^YK		!*Delete string from buffer			!
Z      @27:^UQ%%		!*Append ESC to QQT				!
Z      @27:^UQ%%		!*Append ESC to QQT				!
Z      MQ		!*Execute TECO command				!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-ESC command execution 		!
Z   
Z   QT-^^B"E		!*If command is ESC-B then			!
Z      QO<		!*Do according to repeat count			!
Z        .UA		!*Save current pointer				!
Z        @0,-1:S%^ES%	!*Scan backwards for tabs & blanks		!
Z        "U		!*If unsuccessful then				!
Z          J		!*Jump to beginning of buffer			!
Z          0;		!*Exit the iteration				!
Z        '		!*End "no more" test				!
Z        .-QA+1"G	!*If pointer didn't move backwards then		!
Z          <		!*Begin  iteration to move pointer back		!
Z            -.;		!*Done if at beginning				!
Z            R		!*Back up one character				!
Z            -.;		!*Done if at beginning				!
Z            0A-32"N	!*If not a blank then				!
Z              0A-9"N	!*If not a tab then				!
Z                0A-13"N	!*If not a CR then				!
Z                  0A-10"N	!*If not a LF then			!
Z                    0;	!*Backup is done				!
Z                  '	!*End of LF test				!
Z                '	!*End of CR test				!
Z              '		!*End of TAB test				!
Z            '		!*End of BLANK test				!
Z          >		!*End of backup iteration			!
Z          @0,-1:S%^ES%	!*Scan for 2nd occurance backwards		!
Z          "U		!*If unsuccessful then				!
Z            J		!*Jump to buffer beginning			!
Z          '		!*End of no 2nd occurance test			!
Z        '		!*End of pointer didn't move test		!
Z      >			!*End of ESC-B iteration			!
Z      1^_&QZUZ		!*No append for next kill			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-B command execution		!
Z   
Z    QT-^^F"E		!*If command is ESC-F then			!
Z      QO<		!*Do according to repeat count			!
Z        .UA		!*QAN <= current pointer position		!
Z        @0,1:S%^EL%	!*Look for next line terminator			!
Z        .UB		!*QBN <= possible line terminator pntr		!
Z        QAJ		!*Return to original location			!
Z        @0,1:S%^ES%	!*Scan rest of buffer for tabs & blanks		!
Z        .UC		!*QCN <= possible tab/blank string pntr		!
Z        QB-QA"G		!*If line terminator was also found		!
Z          QC-QB"G	!*If line terminator was first then		!
Z            QBJ		!*Go to it instead				!
Z          '		!*End of line term first test			!
Z        '		!*End of line term also found test		!
Z        .-QA"E		!*If no move was made then			!
Z          0;		!*Exit the iteration if no more			!
Z        '		!*End of no more moves test			!
Z      >			!*End of ESC-F iteration			!
Z      1^_&QZUZ		!*No append for next kill			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-F command execution		!
Z   
Z    QT-^^G"E		!*If command is ESC G then			!
Z      .UA		!*Save initial pointer location			!
Z      J			!*Jump to buffer beginning			!
Z      QO-1L		!*Go down specified number of lines-1		!
Z      QA-."N		!*If not back where we started then		!
Z        1^_&QZUZ	!*No append next kill				!
Z      '			!*End of pointer movement test			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC G command				!
Z
Z    QT-^^N"E		!*If command is ESC-N then 			!
Z      QOP		!*Jump to that page 				!
Z      1^_&QZUZ		!*No kill append				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-N command execution 		!
Z   
Z    QT-^^V"E		!*If command is ESC-V then 			!
Z      -20*QOL		!*Jump back up that many windows 		!
Z      1^_&QZUZ		!*No kill append				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-V command execution 		!
Z 
Z    QT-^^W"E		!*If command is a ESC-W then			!
Z      GZ		!*Pull kill buffer 1 contents into text buffer	!
Z      ^YXY		!*QTY <= second most recent kill		!
Z      ^YK		!*Delete second most recent kill from text buffr!
Z      QM-."G		!*If mark is ahead of pointer then		!
Z        .,QMXZ		!*QZT <= region from pointer+1 to mark		!
Z      |			!*Else if mark is behind pointer then		!
Z        QM,.XZ		!*QZT <= region from mark+1 to pointer		!
Z      '			!*End of mark+1 to pointer region save		!
Z      1^_&QZUZ		!*Set no append					!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-W execution 			!
Z
Z    QT-^^Z"E		!*If command is ESC-Z then			!
Z      0;		!*Exit to teco level				!
Z   '			!*End of ESC-Z command execution		!
Z   
Z    QT-^^%"E		!*If command is ESC % then			!
Z      1UB		!*Enable query					!
Z      !QR!		!*Query replace / replace common point		!
Z      @^UL%Replace:%	!*QLT <= "Replace:"				!
Z      @32:^UL%%		!*QLT <= "Replace: "				!
Z      MN		!*Get the input string				!
Z      "U		!*If failed then				!
Z        F<		!**** Go get next command			!
Z      '			!*End of string fetch abort test		!
Z      GS		!*Get the string that was input			!
Z      ^YXA		!*QAT <= string to replace			!
Z      ^YK		!*Delete string from buffer			!
Z      @^UL%With:%	!*QLT <= "With:"				!
Z      @32:^UL%%		!*QLT <= "With: "				!
Z      MN		!*Get the input string				!
Z      "U		!*If failed then				!
Z        F<		!**** Go get next command			!
Z      '			!*End of string fetch abort test		!
Z      <			!*Begin query replace loop			!
Z        0,1:@S%^EQA%	!*Find string to replace			!
Z        ;		!*If search failed then exit			!
Z        1^_&QZUZ	!*Reset append next kill bit since pointer moved!
Z        32UT		!*Fake a confirm by user			!
Z        QB"N		!*If query is enabled then			!
Z          MP		!*Get response from terminal stream		!
Z          ;		!*If abort then exit loop			!
Z        '		!*End of user query				!
Z        QT-32"E		!*If space bar was pressed then			!
Z          ^YK		!*Kill the last found string			!
Z           GS		!*Replace with replacement string		!
Z           2#QZUZ	!*Set buffer modified bit			!
Z           1^_&QZUZ	!*Reset append next kill bit			!
Z        '		!*End of positive replacement response test	!
Z      >			!*End of query replace loop			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC % command processing		!
Z
Z    QT-^^*"E		!*If command is ESC * then			!
Z      :QQ"N		!*If length of last TECO cmd is not zero then	!
Z        ^^HMM		!*Send cursor to home position			!
Z        ^^JMM		!*Clear the screen				!
Z        :GQ		!*Show the contents of the TECO minibuffer	!
Z        16#QZUZ		!*Disable screen update during command fetch	!
Z        MX		!*Get the next command character (ignored)	!
Z        ^[		!*Discard any returned numeric value		!
Z        16^_&QZUZ	!*Enable screen updates again			!
Z        MO		!*Refresh the status line			!
Z        32^T		!*Force TECO to update screen			!
Z      '			!*End of non null TECO cmd processing		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC * command execution		!
Z
Z    QT-^^<"E		!*If command is ESC-< then 			!
Z      0J		!*Jump to top of buffer 			!
Z      1^_&QZUZ		!*No kill append 				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-< command execution 		!
Z   
Z    QT-^^>"E		!*If command is ESC-> then 			!
Z      ZJ		!*Jump to end of buffer 			!
Z      1^_&QZUZ		!*No kill append 				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-> command execution 		!
Z   
Z    QT-^^@"E		!*If command is ESC-@ then 			!
Z      .UM		!*Set mark at current point 			!
Z      24MH		!*Go ready the prompt line			!
Z      @^A%Set.%		!*Tell user mark is set				!
Z      32768W		!*Tell TECO to forget we messed with screen	!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-@ command execution 		!
Z   
Z    7MM			!*ESC command not found; ring bell 		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command 			!
Z
Z
Z!*^X  COMMAND MACROS 							!
Z
Z    !CX!		!*^X commands start here 			!
Z    MX			!*Get the 2nd char in the ^X command 		!
Z   
Z   ^[			!*Discard any returned numeric value		!
Z
Z    QT-7"E		!*If command is an ^X-^G then			!
Z      F<		!**** Go get next command			!
Z    '			!*End off ^X-^G execution			!
Z
Z    QT"V		!*If 2nd char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-12"E		!*If command is ^X ^L then			!
Z      .UC		!*QCN <= current pointer location		!
Z      QMUA		!*QAN <= Region start (mark location initially)	!
Z      .UB		!*QBN <= Region end (pointer loc initially)	!
Z      QB-QA"L		!*If mark is after pointer then			!
Z        QMUB		!*QBN <= mark location				!
Z        .UA		!*QAN <= pointer location			!
Z      '			!*End of mark/pointer reversal			!
Z      QAJ		!*Jump to start of region			!
Z      QB-QA<		!*For number of characters in region		!
Z        0A"W		!*If next character is uppercase then		!
Z          0A+32@I%%	!*Insert matching lower case character		!
Z          D		!*Delete the uppercase character		!
Z          R		!*Back up over the new lower case character	!
Z          2#QZUZ	!*Set buffer modified bit			!
Z        '		!*End of case conversion			!
Z        C		!*Go check next character			!
Z      >			!*End of case conversion			!
Z      QCJ		!*Jump back to start location			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X ^L processing			!
Z
Z    QT-14"E		!*If command is ^X ^N then			!
Z      6:W-1UA		!*QAN <= buffer loc of char before home position!
Z      QA"N		!*If home position is not top of buffer then	!
Z        8&QZ"N		!*If output file is open then			!
Z          B,QAP		!*Output from top to home to output file	!
Z          .-QAUE	!*Adjust pointer to current loc BEFORE delete	!
Z          B,QAD		!*Delete from buffer				!
Z          QEJ		!*Jump to adjusted buffer loc (same rel pos)	!
Z          ^E"N		!*If previous read found form feed then		!
Z            ZJ		!*Jump to buffer end				!
Z            12@I%%	!*Insert a form feed character			!
Z            QEJ		!*Jump back to original location		!
Z          '		!*End of form feed append if necessary		!
Z          A		!*Append a new page to current page		!
Z        '		!*End of output file open processing		!
Z      '			!*End of across page boundry append		!
Z    1^_&QZUZ		!*No append next kill				!
Z    F<			!**** Go get next command			!
Z    '			!*End of ^X^N processing			!
Z
Z    QT-18"E		!*If command is ^X-^R then			!
Z      @^UL%Read%	!*QLT <= "Read"					!
Z      @32:^UL%%		!*QLT <= "Read "				!
Z      @:^UL%file:%	!*QLT <= "Read file:"				!
Z      @32:^UL%%		!*QLT <= "Read file: "				!
Z      MN		!*Go get input string				!
Z      "U		!*If string fetch was unsuccessful then		!
Z        F<		!**** Go get next command			!
Z      '			!*End of zero-length string test		!
Z      GS		!*Pull file string into buffer			!
Z      ^YXB		!*Put in QBT for safe keeping			!
Z      ^YK		!*Purge from buffer				!
Z      8&QZ"N		!*If output file is open then			!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          EC		!*Move buffer to file and close file		!
Z        |		!*Else if buffer has not been modified then	!
Z          EK		!*Kill the output file				!
Z        '		!*End of output file open processing		!
Z      |			!*Else if output file is not open then		!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          MU		!*Take action to save the buffer or delete it	!
Z          "U		!*If aborted then				!
Z            F<		!**** Go get next command			!
Z          '		!*End of abort trap				!
Z        '		!*End of buffer modified processing		!
Z      '			!*End of output file open/closed processing	!
Z      2#8^_&QZUZ	!*Reset modified and output file open bits	!
Z      @^UA%@:ER/%	!*QTA <= all characters between "%" s		!
Z      GB		!*Get the file string				!
Z      ^Y:XA		!*Append it to EB command			!
Z      @:^UA%/%		!*Append all char between "%" s to QTA		!
Z      HK		!*Purge current buffer				!
Z      4^_&QZUZ		!*Reset input file open bit			!
Z      MA		!*Try to open an old file for read only		!
Z      "S		!*If successful open then			!
Z        G*		!*Pull file file-spec into buffer		!
Z        ^YXK		!*QKT <= primary input filespec			!
Z        HK		!*Purge buffer					!
Z        A		!*Pull in first page of the file		!
Z        4#QZUZ		!*Set input file open 				!
Z      '			!*End of successful open execution		!
Z      1#2^_&QZUZ	!*No kill append; buffer not modified		!
Z      MO		!*Update the status line			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-^R execution			!
Z
Z    QT-19"E		!*If command is ^X ^S then			!
Z      8&QZ"N		!*If output file is open then			!
Z        EC		!*Move out rest of input file and close output	!
Z        2#8^_&QZUZ	!*Reset modified and output file open bits	!
Z        @^UA%@EB/%	!*QAT <= "@EB/"					!
Z        GT		!*Pull output file spec into text buffer	!
Z        ^S+.J		!*Jump back to beginning of string (revs bug)	!
Z        .UA		!*QAN <=  loc before first filespec character	!
Z	@S%;%		!*Search FORWARD for first ; character		!
Z        QA,.-1:XA	!*Append filename minus the version number	!
Z        @:^UA%/%	!*QAT <= "@EB/<filename>/"			!
Z        HK		!*Purge current buffer				!
Z        MA		!*Open the previous file for both input & output!
Z        G*		!*Get the new file spec				!
Z        ^YXT		!*QTT <= new output file spec			!
Z        ^YXK		!*QKT <= new input file spec			!
Z        HKA		!*Purge buffer and pull  in first page of file	!
Z        1#4#8#QZUZ	!*No kill append, output and input files open	!
Z      '			!*End of file save for open output file		!
Z      MO		!*Update the status line to show new filename	!
Z      F<		!**** Go get next command			!
Z    '			!* End of ^X ^S execution			!
Z
Z    QT-21"E		!*If command is ^X ^U then			!
Z      .UC		!*QCN <= current pointer location		!
Z      QMUA		!*QAN <= Region start (mark location initially)	!
Z      .UB		!*QBN <= Region end (pointer loc initially)	!
Z      QB-QA"L		!*If mark is after pointer then			!
Z        QMUB		!*QBN <= mark location				!
Z        .UA		!*QAN <= pointer location			!
Z      '			!*End of mark/pointer reversal			!
Z      QAJ		!*Jump to start of region			!
Z      QB-QA<		!*For number of characters in region		!
Z        0A"V		!*If next character is lowercase then		!
Z          0A-32@I%%	!*Insert matching uppercase character		!
Z          D		!*Delete the lowercase character		!
Z          R		!*Back up over the new uppercase character	!
Z          2#QZUZ	!*Buffer modified				!
Z        '		!*End of case conversion			!
Z        C		!*Go look at next character			!
Z      >			!*End of case conversion			!
Z      QCJ		!*Jump back to start location			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X ^U processing			!
Z
Z    QT-22"E		!*If command is ^X-^V then			!
Z      @^UL%Visit%	!*QLT <= "Visit"				!
Z      @32:^UL%%		!*QLT <= "Visit "				!
Z      @:^UL%file:%	!*QLT <= "Visit file:"				!
Z      @32:^UL%%		!*QLT <= "Visit file: "				!
Z      MN		!*Go get input string				!
Z      "U		!*If string fetch was unsuccessful then		!
Z        F<		!**** Go get next command			!
Z      '			!*End of zero-length string test		!
Z      GS		!*Pull file string into buffer			!
Z      ^YXB		!*Put in QBT for safe keeping			!
Z      ^YK		!*Purge from buffer				!
Z      8&QZ"N		!*If output file is open then			!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          EC		!*Move the new buffer to output file & close it	!
Z        |		!*Else if buffer has not been modified then	!
Z          EK		!*Kill the output file				!
Z        '		!*End of kill unmodified buffer & kill file	!
Z      |			!*Else  if output file is not open then		!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          MU		!*Take action to save the buffer		!
Z          "U		!*If aborted then				!
Z            F<		!**** Go get next command			!
Z          '		!*End of abort trap				!
Z        '		!*End of buffer modified processing		!
Z      '			!*End of output file is open/closed processing	!
Z      2#8^_&QZUZ	!*Reset modified and output file open bits	!
Z      @^UA%@:EB/%	!*QTA <= all characters between "%" s		!
Z      GB		!*Get the file string				!
Z      ^Y:XA		!*Append it to EB command			!
Z      @:^UA%/%		!*Append all char between "%" s to QTA		!
Z      HK		!*Purge buffer					!
Z      MA		!*Try to open an old file with backup		!
Z      "S		!*If successful open then			!
Z        G*		!*Pull complete filespec into buffer		!
Z        ^YXT		!*QTT <= new output filespec			!
Z        ^YXK		!*QKT <= new input filespec			!
Z        HKA		!*Kill current buffer and pull in next		!
Z        4#8#QZUZ	!*Set input file open & output file open bit	!
Z      |			!*Else if not successful open with backup then	!
Z        @^UA%@EW/%	!*QTA <= all char between "%" s 		!
Z        GS		!*Pull file name back into buffer		!
Z        ^Y:XA		!*Append the file string to QTA			!
Z        ^YK		!*Kill file name in case it bombs		!
Z        @:^UA%/%	!*Append the final commands to QTA		!
Z        MA		!*Open a new file				!
Z        G*		!*Pull output filespec into buffer		!
Z        ^YXT		!*QTT <= new output file spec			!
Z        HK		!*Purge the buffer				!
Z        8#QZUZ		!*Set output file open bit			!
Z      '			!*End of open file execution			!
Z      1#2^_&QZUZ	!*No kill append; buffer not modified		!
Z      MO		!*Update status line				!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-^V execution			!
Z
Z    QT-23"E		!*If command is ^X-^W then			!
Z      @^UL%Write%	!*QLT <= "Write"				!
Z      @32:^UL%%		!*QLT <= "Write "				!
Z      @:^UL%file:%	!*QLT <= "Write file:"				!
Z      @32:^UL%%		!*QLT <= "Write file: "				!
Z      MN		!*Go get input string				!
Z      "U		!*If string fetch was unsuccessful then		!
Z        F<		!**** Go get next command			!
Z      '			!*End of zero-length string test		!
Z      8&QZ"N		!*If output file is open then			!
Z        EF		!*Close the output file with no output		!
Z        8^_&QZUZ	!*Reset output file open bit			!
Z      '			!*End of output file is open processing		!
Z      @^UA%@:EW/%	!*QTA <= all characters between "%" s		!
Z      GS		!*Get the file string				!
Z      ^Y:XA		!*Append it to EW command			!
Z      ^YK		!*Delete file string from text buffer		!
Z      @:^UA%/%		!*Append all char between "%" s to QTA		!
Z      MA		!*Open a new output file			!
Z      "S		!*If successful open then			!
Z        G*		!*Pull in complete file spec			!
Z        ^YXT		!*QTT <= output filespec			!
Z        ^YK		!*Kill filespec from buffer			!
Z        2#8#QZUZ	!*Mark as modified; output file open		!
Z      '			!*End of open success test			!
Z      MO		!*Update  the status line			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-^W execution			!
Z
Z    QT-24"E		!*If command is a ^X-^X then 			!
Z      .UN		!*QN <= current pointer loc (next mark) 	!
Z      QMJ		!*Jump to marked position 			!
Z      QNUM		!*Set mark at previous pointer loc 		!
Z      1^_&QZUZ		!*No kill append 				!
Z      F<		!**** Go get next user command 			!
Z    '			!*End of ^X-^X command execution 		!
Z   
Z    QT-27"E		!*If command is ^X-ESC then 			!
Z      MQ		!*Re-execute TECO macro in Q9			!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ^X-ESC command execution 		!
Z   
Z    QT-^^A"E		!*If command is ^X A then			!
Z      4&QZ"N		!*If input file is open then			!
Z        ^E"N		!*If previous read found a form feed then	!
Z          .UA		!*QAN <= current pointer position		!
Z          ZJ		!*Jump to end of buffer				!
Z          12@I%%	!*Insert a form feed				!
Z          QAJ		!*Jump back to original point			!
Z        '		!*End of form feed append if necessary		!
Z        A		!*Append from input file			!
Z      '			!*End of append					!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X A command execution			!
Z
Z    QT-^^E"E		!*If command is ^X-E then			!
Z      -:QWUY		!*Initialize up-counter for # of commands	!
Z      -QOUX		!*Initialize macro repeat count			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-E execution				!
Z
Z   QT-^^N"E		!*If command is ^XN then			!
Z      .UE		!*QEN <= Current pointer location		!
Z      MR		!*Get cursor line number			!
Z      -1UB		!*QBT <= # lines to get to home position	!
Z      -QBL		!*Jump to start of first line on screen		!
Z      .UA		!*QAN <= Char pointer value at home position	!
Z      QEJ		!*Jump back to original location		!
Z      QA"N		!*If home position is not top of buffer then	!
Z        8&QZ"N		!*If output file is open then			!
Z          .-QAUE	!*Adjust pointer to current location before del	!
Z          B,QAP		!*Output from top to home to output file	!
Z          B,QAD		!*Delete from buffer				!
Z          QEJ		!*Go to original location			!
Z        '		!*End of output file open processing		!
Z      '			!*End of make room execution			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^XN processing				!
Z
Z    QT-^^Q"E		!*If command is ^X-Q then			!
Z      QY"L		!*If macro command fetch in progress then	!
Z        MP		!*Get next command from terminal stream only	!
Z        QQ"E		!*If response is ^G then			!
Z          F<		!**** Go get next command			!
Z        '		!*End of ^G response processing			!
Z        QT-32"N		!*If next input is not space char then		!
Z          0UY		!*Set macro fetch counter to zero to force exit	!
Z          %X		!*Increment macro repeat counter		!
Z          "L		!*If more macro loops left to be done then	!
Z            -:QWUY	!*Restore command counter contents		!
Z          '		!*End of macro command counter restore		!
Z        '		!*End of macro abort test			!
Z      '			!*End of macro command query operation		!
Z      F<		!**** go get next command			!
Z    '			!*End of ^X-Q execution				!
Z
Z    QT-^^T"E		!*If command is ^X T then			!
Z      QY"L		!*If macro command fetch in progress then	!
Z        -1W		!*Update terminal screen			!
Z      '			!*End of commmand fetch in progress execution	!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X T execution				!
Z
Z    QT-^^*"E		!*If command is ^X-*				!
Z      :QW"N		!*If macro string is not null then		!
Z        ^^HMM		!*Send cursor home				!
Z        ^^JMM		!*Clear the screen				!
Z        :GW		!*Show user the current macro string		!
Z        16#QZUZ		!*Inhibit screen update				!
Z        MX		!*Get the next character			!
Z        ^[		!*Discard any returned numeric value		!
Z        16^_&QZUZ	!*Reset screen update inhibit bit		!
Z        MO		!*Refresh the status line			!
Z        32^T		!*Force TECO to update screen			!
Z      '			!*End of non null macro string processing	!
Z      F<		!**** Go get next command			!
Z    '			!*End of X-* processing				!
Z
Z    QT-^^("E		!*If command is ^X-( then			!
Z      32#QZUZ		!*Set macro collection bit in control word	!
Z      0,0XW		!*Purge previous macro (if any)			!
Z      MO		!*Update the status line			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-( execution				!
Z
Z    QT-^^)"E		!*If command is ^X-) then			!
Z      32&QZ"N		!*If macro collection bit is set		!
Z        GW		!*Get the current EMACS macro			!
Z        ^Y-2XW		!*Push back minus the ^X and ) char		!
Z        ^YK		!*Delete from text buffer			!
Z        32^_&QZUZ	!*Reset macro collection bit in control word	!
Z        MO		!*Update the status line			!
Z      '			!*End of macro collection termination		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-) execution				!
Z
Z    QT-^^="E		!*If command is ^X = then			!
Z      .UA		!*QAN <= current pointer position		!
Z      J			!*Jump to beginning of buffer			!
Z      1UB		!*QBN <= initial line number			!
Z      <			!*Start line count iteration			!
Z        L		!*Go down one line				!
Z        .-QA;		!*If past original start point then exit iter	!
Z        %B		!*Increment the line count			!
Z      >			!*End of line count iteration			!
Z      ."G		!*If buffer is not empty then			!
Z        .-QA"E		!*If at original start point then		!
Z          -1A-10"E	!*If previous character is a LF then		!
Z            %B		!*Increment the line count again		!
Z          '		!*End of CRLF test				!
Z        '		!*End of past start point test			!
Z      '			!*End of buffer not empty test			!
Z      QAJ		!*Jump back to original start point		!
Z      0L		!*Go to start of that line			!
Z      QA-.UC		!*QCN <= number of characters over		!
Z      QAJ		!*Jump back to original start point		!
Z      ^^HMM		!*Send cursor to home position			!
Z      ^^JMM		!*Clear the screen				!
Z      @^A%Line%		!*Show line number header			!
Z      32^T		!*Send blank to terminal			!
Z      QB=		!*Show value to user				!
Z      @^A%After%	!*Send char number header			!
Z      32^T		!*Send blank to terminal			!
Z      @^A%character%	!*Send rest of char number header		!
Z      32^T		!*Send another blank to terminal		!
Z      QC=		!*Show value to user				!
Z      16#QZUZ		!*Inhibit screen update during next cmd fetch	!
Z      MX		!*Get next char from command stream (ignored)	!
Z      ^[		!*Discard any returned numeric value		!
Z      16^_QZUZ		!*Enable screen updates again			!
Z      MO		!*Refresh the status line			!
Z      32^T		!*Force TECO to update screen on next -1W	!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X = command execution			!
Z
Z    7MM			!*^X command not found; ring bell 		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command 			!
Z
Z
Z!* ESC-X MACROS START HERE						!
Z   
Z    !$X!		!*Begin ESC-X macros				!
Z    MX			!*Get next command character			!
Z
Z    ^[			!*Discard any returned numeric value		!
Z
Z    QT"V		!*If char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-7"E		!*If command is an ESC-X-^G then		!
Z      F<		!**** Go get next command			!
Z    '			!*End off ESC-X-^G execution			!
Z
Z    QT-^^C"E		!*If command is an ESC X C then			!
Z      3:W"E		!*If see-all mode is off then			!
Z        1,3:W		!*Turn see-all mode on				!
Z      |			!*Else if see-all mode is on then		!
Z        0,3:W		!*Turn see-all mode off				!
Z      '			!*End of see-all state flip-flop		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X C processing			!
Z
Z    QT-^^D"E		!*If command is an ESC X D then			!
Z      ^BUA		!*QAN <= code for current date			!
Z      QA/512UB		!*QBN <= current year				!
Z      QA-(QB*512)/32UC	!*QCN <= current month				!
Z      QA-(QA/32*32)UD	!*QDN <= current day				!
Z      QC-10"L		!*If month is less than 10 then			!
Z        @I%0%		!*Insert a leading 0 in text buffer		!
Z      '			!*End of leading zero insertion			!
Z      QC\		!*Insert month in text buffer			!
Z      @I%-%		!*Insert "-" character in text buffer		!
Z      QD-10"L		!*If day is less than 10 then			!
Z        @I%0%		!*Insert a leading zero				!
Z      '			!*End of leading zero insertion			!
Z      QD\		!*Insert day in text buffer			!
Z      @I%-%		!*Insert a "-" in text buffer			!
Z      QB-10"L		!*If year is less than 10 then			!
Z        @I%0%		!*Insert a "0" in text buffer			!
Z      '			!*End of leading zero insertion			!
Z      QB\		!*Insert year in text buffer			!
Z      1^_&QZ#2UZ	!*No append next kill; buffer modified		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X D execution			!
Z
Z    QT-^^O"E		!*If command is an ESC X O then			!
Z      @^UL%String:%	!*QLT <= "String:"				!
Z      @32:^UL%%		!*QLT <= "String: "				!
Z      MN		!*Get the search string				!
Z      "U		!*If string fetch failed then			!
Z        32768W		!*Tell TECO to forget we fiddled with screen	!
Z        F<		!**** Go get next command			!
Z      '			!*End of fetch failed trap			!
Z      .UE		!*Save current buffer pointer			!
Z      @:S%^EQS%		!*Find an occurance of string (if any)		!
Z      "S		!*If there is at least one then			!
Z        ^^HMM		!*Send cursor home				!
Z        ^^JMM		!*Erase screen					!
Z        <		!*Begin iteration to display occurances		!
Z          0L		!*Go to start of line containing occurance	!
Z          T		!*Show line to user				!
Z          L		!*Resume search at next line			!
Z          @:S%%		!*Look for next occurance			!
Z          ;		!*Exit iteration when no more found		!
Z        >		!*End of search & show loop			!
Z        QEJ		!*Return to original location			!
Z        16#QZUZ		!*Inhibit screen update during input		!
Z        MX		!*Get next character from input stream		!
Z        ^[		!*Discard any returned numeric value		!
Z        16^_&QZUZ	!*Enable screen updates again			!
Z        MO		!*Refresh status line				!
Z        32^T		!*Force TECO to update screen on next -1W	!
Z      '			!*End of occurances display when string found	!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X O processing			!
Z
Z    QT-^^R"E		!*If command is an ESC X R 			!
Z      0UB		!*Disable query					!
Z      @O!QR!		!*Jump to query replace / replace common	!
Z    '			!*End of ESC X R processing			!
Z
Z    QT-^^T"E		!*If command is an ESC X T then			!
Z      ^HUA		!*QAN <= # seconds since midnight / 2		!
Z      QA/1800UB		!*QBN <= # hours since midnight			!
Z      QA-(QB*1800)/30UC	!*QCN <= # minutes in current hour		!
Z      QA-(QA/30*30)*2UD	!*QDN <= # seconds in current minute		!
Z      QB-10"L		!*If # hours is less than 10 then		!
Z        @I%0%		!*Insert a "0" in text buffer			!
Z      '			!*End of leading zero insertion			!
Z      QB\		!*Insert # hours in text buffer			!
Z      @I%:%		!*Insert a ":" in text buffer			!
Z      QC-10"L		!*If # minutes is less than 10 then		!
Z        @I%0%		!*Insert a leading 0 in text buffer		!
Z      '			!*End of leading zero insertion			!
Z      QC\		!*Insert # minutes in text buffer		!
Z      @I%:%		!*Insert ":" character in text buffer		!
Z      QD-10"L		!*If # seconds is less than 10 then		!
Z        @I%0%		!*Insert a leading zero				!
Z      '			!*End of leading zero insertion			!
Z      QD\		!*Insert # seconds in text buffer		!
Z      1^_&QZ#2UZ	!*No append next kill; buffer modified		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X T execution			!
Z
Z    7MM			!*ESC-X command not found; ring bell		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command			!
Z
Z
Z!*^Z MACROS START HERE							!
Z   
Z    !CZ!		!*Begin ^Z macros				!
Z    MX			!*Get next command character			!
Z   
Z    ^[			!*Discard any returned numeric value		!
Z
Z    QT"V		!*If 2nd char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-6"E		!*If command is ^Z-^F then			!
Z      GT		!*Get filename 					!
Z      1^_&QZ#2UZ	!*No append; modified				!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^Z-^F execution			!
Z
Z    QT-7"E		!*If command is an ^Z-^G then			!
Z      F<		!**** Go get next command			!
Z    '			!*End off ^Z-^G execution			!
Z
Z    QT-26"E		!*If command is ^Z-^Z then close files and exit	!
Z      8&QZ"N		!*If output file is open then			!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          EC		!*Move rest of file to output and close file	!
Z        |		!*Else if buffer has not been modified then	!
Z          EK		!*Kill the output file				!
Z        '		!*End of output open processing			!
Z      |			!*Else if output file is not open then		!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          MU		!*Take steps to save or purge buffer		!
Z          "U		!*If aborted then				!
Z            F<		!**** Go get next command			!
Z          '		!*End of abort trap				!
Z        '		!*End of modified buffer test			!
Z      '			!*End of output file open/closed processing	!
Z      ^^HMM		!*Send cursor home				!
Z      ^^JMM		!*Erase screen					!
Z      HK		!*Purge the buffer to insure exit capability	!
Z      EX		!*Exit the editor				!
Z    '			!*End of ^Z-^Z execution			!
Z
Z    7MM			!*ESC-X command not found; ring bell		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command			!
Z   
Z  >			!*						!
Z~
Z   
Z!* END OF MACRO LOADS INTO Q REGISTERS					!
Z   
ZHK			!*Purge the buffer				!
ZMI			!*Begin execution of infinite iteration		!
Z!BY!			!*Jump in point for non-EMACS bypass		!
Z
STUNKYFLUFF
set `sum emacs.src`
if test 43403 != $1
then
echo emacs.src: Checksum error. Is: $1, should be: 43403.
fi
#
#
echo Extracting emacs.txt:
sed 's/^Z//' >emacs.txt <<\STUNKYFLUFF
Z                          Instructions Summary
Z			  --------------------
Z
ZPointer movement cmds:
Z---------------------
Z
Z  ^A	   =>	Go to beginning of current line.
Z
Z  ^B	   =>	Go back one character.
Z
Z  ^E       =>	Go to end of line.
Z
Z  ^F	   =>	Go forward one character.
Z
Z  ^N	   =>	Go to same place in next line.
Z
Z  ^P	   =>	Go to same place in previous line.
Z
Z  ^V	   =>	Move window down.
Z
Z  ESC A    =>	Go backward to start of sentence.
Z		[Not yet implemented]
Z
Z  ESC B	   =>	Go back one word.
Z
Z  ESC E    =>	Go forward to start of next sentence.
Z		[Not yet implemented]
Z
Z  ESC F	   =>	Go forward one word.
Z
Z  ESC G    =>	Go to specified line number in current buffer.
Z		(precede command with line number as ESC<digits>)
Z
Z  ESC V	   =>	Move window up.
Z
Z  ESC [    =>	Go to beginning of paragraph.
Z		[Not yet implemented]
Z
Z  ESC ]    =>	Go to end of paragraph.
Z		[Not yet implemented]
Z
Z  ESC <	   =>	Go to beginning of buffer.
Z
Z  ESC >	   =>	Go to end of buffer.
Z
Z  ^X ^X	   =>	Exchange mark and pointer
Z
Z  ^X =     =>	Displays information about current position in
Z		buffer.
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z  
ZBuffer page commands
Z--------------------
Z
Z
Z  ESC N	   =>	Write current buffer to output file, clear buffer,
Z		and read in next page from input file.
Z
Z  ^X  A    =>	Append next page to buffer. Inserts form feed if
Z		last read found a form feed.
Z
Z  ^X ^N    =>	Write all text in buffer above the current window
Z		to the output file and read in next page from
Z		input file.  (Useful for editing near page boundries.)
Z
Z  ^X  N    =>	Same as ^X ^N but does not read in next page.  Useful
Z		for making some room in the buffer.
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z  
Z
ZSearch commands:
Z----------------
Z
Z  ^S	   =>	Incremental forward search.  Searches for string
Z		as each character is input.  Can only be exited with:
Z
Z		(1) ESC to signify stay at current location after
Z		    string found.
Z
Z		(2) ^G to abort and return to original location.
Z
Z		Notes:	1. "DELETE" removes characters from search
Z			    string.
Z			2.  When search string is null (empty) a 2nd
Z			    ^S within a search operation uses the most
Z			    recent successful search string.
Z			3.  A 2nd ^S  at any other time within a search
Z			    operation finds the next occurance of the 
Z			    current search string.
Z
Z  ^R        =>	Incremental reverse search.  Same as ^S except search
Z		progresses backwards.  Leaves pointer at beginning of
Z		string found.
Z		[Not yet implemented]
Z
Z
Z  ESC X O   =>	"Occurances".  Display all lines containing a specified
Z		string.
Z
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
ZKill and delete commands:
Z-------------------------
Z
Z   Kill operations either initialize the kill buffer with the removed
Z   text, or append the removed text to the current kill buffer contents,
Z   depending upon whether or not the pointer has moved since the last
Z   kill operation.  (appends if hasn't moved)
Z
Z   Delete operations remove the affected text and discard it.
Z
Z
Z  ^D	   =>	Delete next character.
Z
Z  ^K	   =>	Kill to end of line / kill line terminator.
Z
Z  ^W	   =>	Kill marked region.
Z
Z  ^Y	   =>	Yank back last kill.  (insert text stored in kill buffer)
Z
Z  ESC D    =>	Delete next word.  
Z		[Not yet implemented]
Z
Z  ESC K    =>	Kill to end of sentence.
Z		[Not yet implemented]
Z
Z  ESC W	   =>	Copy region between mark and pointer to kill buffer,
Z		superceding existing text.
Z
Z  ESC Y    =>	If used immediately after ^Y replaces the text just
Z		"unkilled" with the text that was the 2nd most recent
Z		victim.
Z		[Not yet implemented]
Z
Z  ESC ^Y   =>	Yanks (pulls) last defined TECO command into text
Z		buffer.
Z
Z  ESC ^W   =>	Append next kill to text already in kill buffer (if any).
Z		(nullified by any pointer movement or text insertion)
Z
Z  ^X ^O    =>	Delete blank lines from current pointer to next non-blank
Z		line.
Z		[Not yet implemented]
Z
Z  ^X #     =>	Kill backwards to start of sentence.
Z		[Not yet implemented]
Z
Z  "DELETE" =>	Delete character before pointer.
Z    KEY
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
Z  
ZTECO related cmds:
Z------------------
Z
Z
Z  ESC ESC  =>	Enter TECO commands.  Terminate with double ESC or
Z		abort with ^G.
Z
Z  MI ESC ESC =>	Restart EMACS from TECO level.
Z
Z  ESC ^Y   =>	Insert last defined TECO command into text buffer.
Z
Z  ESC Z    =>	Return to TECO level. (can restart EMACS with MI$$)
Z
Z  ESC *    =>	View last TECO command
Z
Z  ^X ESC   =>	Re-execute TECO command most recently entered with
Z		ESC ESC command.
Z
Z
Z
Z
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
Z  
Z
ZMiscellaneous cmds:
Z-------------------
Z
Z  ^C	   =>	Return to TECO level.  (can restart EMACS with MI$$)
Z
Z  ^G	   =>	*** THIS IS THE PANIC BUTTON ***
Z		Gets you out of almost anything as long as EMACS is
Z		not "hung".
Z
Z  ^O	   =>	Open blank line for insertion.
Z
Z  ^Q	   =>	Use next character as text.  (inserts cmds as text)
Z
Z  ESC S    =>	Center text in current line.  Uses a default of
Z		80 characters per line or can be preceded with
Z		an argument of form ESC<digits> which defines
Z		number of characters in line.
Z		[Not yet implemented]
Z
Z  ESC T    =>	Exchange words before and after pointer (does
Z		nothing if pointer is inside a word).
Z		[Not yet implemented]
Z
Z  ESC %    =>	"Query replace" --- Prompt for search string and its
Z		replacement, then from current pointer to end of file,
Z		find string and query user as follows:
Z		(1) Space bar: go ahead and replace this occurance.
Z		(2) ^G : abort query replace.
Z		(3) Any other key: don't replace, find next.
Z
Z  ^X I     =>	Insert file at current pointer position.  First executes
Z		a ^X ^N to make room in the buffer.
Z		[Not yet implemented]
Z
Z  ESC X C  =>	Enter/exit "see-all" mode (shows ALL char in a file,
Z		even non-printing ones, with special graphics)
Z
Z  ESC X D  =>	Insert current date in text buffer in form  MM-DD-YR
Z
Z  ESC X R  =>	"Replace" --- Prompt for search string and its
Z		replacement, then from current pointer to end of buffer,
Z		replace all occurances.
Z
Z  ESC X T  =>	Insert current time in text buffer in form  HH:MM:SS
Z
Z  ^_       =>	"Help on tap" --- Interactive help processor.
Z		[Not yet implemented]
Z
Z  ESC ?    =>	"Describe" --- Describe function of next command
Z		without executing it.
Z		[Not yet implemented]
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
ZFile related commands:
Z----------------------
Z
Z  ^X-^R	   =>	"Read file"
Z		Reads in first page of a given file after closing the
Z		currently open file (if any).
Z
Z  ^X-^S    =>	"Save file"
Z		Writes buffer and rest of currently open input file to
Z		currently open output file, closes and reopens file, and
Z		reads first page back in.
Z
Z  ^X-^V	   =>	"Visit file"
Z		Opens a given file for both input and output after closing
Z		the currently open output file (if any).
Z
Z  ^X-^W	   =>	"Write file"
Z		Sets output file to that specified, after closing any
Z		currently open output file (if any).
Z
Z  ^Z-^F	   =>	"Get file name"
Z		Insert most recently specified output filename into text
Z		buffer.
Z
Z  ^Z-^Z	   =>	"Close files and exit"
Z		Close all files and exit EMACS.
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
Z
Z
ZKeyboard macro cmds:
Z--------------------
Z
Z  ^X (	   =>	Start EMACS macro collection.
Z
Z  ^X )	   =>	Terminate EMACS macro collection.
Z
Z  ^X-*     =>	"View last macro" --- Clears screen and displays
Z		last defined EMACS macro.  Pressing any key returns
Z		to edit mode.  Note some "commands" such as CRLF
Z		are displayed in image mode.  This is built into TECO.
Z
Z  ^X T     =>	"Toggle update" --- Forces screen update at current
Z		command inside a macro.  Useful for verifying macro
Z		is executing properly by viewing results at specific
Z		points, buts slows down execution considerably.
Z
Z  ^X E	   =>   Execute most recently collected EMACS macro.
Z
Z  ^X Q	   =>	When used inside a macro halts execution and waits for
Z		the user to either:
Z		(1) press space bar to continue with current macro.
Z		(2) use ^G to abort this macro and all macro repeats
Z		    pending.
Z		(2) press any other key to exit current macro, without
Z		    effecting any pending macro repeats.
Z
Z  ESC X S  =>	"Save macro" --- Saves current EMACS macro in a specified
Z		file.  Prompts for file name.
Z		[Not yet implemented]
Z
Z  ESC X L  =>	"Load macro" --- Loads EMACS macro from a specified file.
Z		Prompts for file name.
Z		[Not yet implemented]
Z
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
Z
ZThe "mark" and region cmds:
Z---------------------------
Z
Z
Z  ESC H    =>	Mark paragraph.  Puts mark at beginning of paragraph,
Z		pointer at end.
Z		[Not yet implemented]
Z
Z  ^X ^P    =>	Mark page ---  Put mark at top of page, defined to be
Z		immediately after first form feed backwards from
Z		current pointer, or top of buffer, whichever is first.
Z		Put pointer at bottom of page, defined to be immediately
Z		after next form feed forwards from current pointer, or
Z		bottom of buffer, whichever is first.
Z		[Not yet implemented]
Z
Z  ^X ^X    =>	Exchange mark and pointer; useful to verify where
Z		current region is.
Z
Z  ESC @    =>	Set mark at current pointer (is EMACS ^@).
Z
Z  ESC X A  =>	Append currently defined region to an existing file.
Z		Prompts for file name.
Z		[Not yet implemented]
Z
Z  ESC X P  =>	Prepend currently defined region to an existing file.
Z		Prompts for file name.
Z		[Not yet implemented]
Z
Z  ESC X W  =>	Write currently defined region to a new file.  Prompts
Z		for file name.
Z		[Not yet implemented]
Z
Z
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
Z
ZCase conversion cmds:
Z---------------------
Z
Z
Z   ESC C    =>	Capitalize next word.
Z		[Not yet implemented]
Z
Z   ESC L    =>	Lower case next word.
Z		[Not yet implemented]
Z
Z   ESC U    =>	Upper case next word.
Z		[Not yet implemented]
Z
Z   ^X ^L    =>	Lower case marked region.
Z
Z   ^X ^U    =>	Upper case marked region.
Z
Z                    Instructions Summary (cont).
Z		    ----------------------------
Z
Z
Z
ZMisc. notes:
Z------------
Z
Z   1.	Most commands can be preceded with a repeat count of the form
Z	ESC<digits>.  Even "commands" which are self-insertions, I.E.
Z	ESC20H inserts 20 "H"s in text buffer.
Z
Z   2.   Commands which "view information" (such as ESC X O  or ^X =)
Z	wait for the user to press any key and then return the screen
Z	to its normal window mode into the text buffer.  The character
Z	input by the single key stroke is discarded.  The text buffer
Z	is not affected by the view operation.
Z
STUNKYFLUFF
set `sum emacs.txt`
if test 16227 != $1
then
echo emacs.txt: Checksum error. Is: $1, should be: 16227.
fi
#
#
echo Extracting emacs11.tec:
sed 's/^Z//' >emacs11.tec <<\STUNKYFLUFF
Z	EMACS11.TEC   ---	EMACS command compatable editor for	
Z				PDP-11 and VAX systems which have
Z				TECO, version 35 or later.
Z
Z        Last modified:		05-24-82 17:13:52  by Fred Fish
Z									
Z
Z	Q register usage:						
Z									
Z		Note:	For each Q register number there are TWO	
Z			storage areas, one for numeric data and one for 
Z			text.  They are refered to here as QnN and	
Z			QnT respectively, where "n" is the Q register	
Z			number.						
Z									
Z			In general, low alphabetic Q registers are	
Z			used for local storage and high alphabetic	
Z			Q registers are used for global storage and	
Z			macros.						
Z									
Z									
Z		QMN  =>	Marked location pointer.  Contains numeric 	
Z			  pointer to last character location at which	
Z			  a mark was set.				
Z									
Z		QNN  =>	Current pointer save.				
Z									
Z		QON  =>	Repeat count.  For commands which support using	
Z			  a repeat count preceding the command of the	
Z			  form <ESC><digits>, the count is stored in	
Z			  this register.				
Z									
Z		QQN  => Abort back to highest level if set to 0		
Z									
Z		QWN  =>	Last column number of a ^N or ^P command
Z
Z		QTN  =>	Current command character ascii value		
Z									
Z		QXN  => Macro repeat count				
Z									
Z		QYN  => Emacs macro command fetch down counter		
Z									
Z		QZN  =>	Control flags word				
Z									
Z		QHT  => Macro to move cursor to a given line,
Z			erase that line, leave cursor at beginning
Z			of that line, and make TECO forget it did
Z			anything to screen.
Z
Z		QIT  => Contains most of the run time macros which
Z			make up the specific commands for EMACS.
Z			Overwrite this and you've wiped out the
Z			editor!
Z
Z		QKT  =>	Primary input file full file-spec
Z
Z		QLT  =>	Search prompt.					
Z									
Z		QMT  =>	Contains terminal image mode macro.		
Z									
Z		QNT  =>	Contains string input macro			
Z									
Z		QOT  =>	Editor status line update macro
Z
Z		QPT  => Macro to get next character from terminal	
Z									
Z		QQT  =>	TECO command minibuffer. 			
Z									
Z		QRT  =>	Macro to find screen line number as num arg	
Z									
Z		QST  =>	String fetched by prompt/string input macro	
Z									
Z		QTT  =>	Output filespec for currently open output file	
Z									
Z		QUT  =>	Macro to allow option of saving modified 	
Z			buffer when no output file is open.		
Z									
Z		QVT  => Last successful EMACS search string		
Z									
Z		QWT  =>	Emacs macro command string			
Z									
Z		QXT  => Macro to fetch next command from terminal	
Z			stream or EMACS macro stream (calls QPT macro)	
Z									
Z		QYT  =>	Kill buffer 2 (contains next most recent kill)	
Z									
Z		QZT  =>	Kill buffer 1 (contains most recent kill)	
Z									
Z	LABEL POINTS:							
Z									
Z		A   =>							
Z									
Z		B   =>							
Z									
Z		F   =>							
Z									
Z		M   =>	^N and ^P common processing point.		
Z									
Z		QR  =>	Query replace / replace common processing	
Z									
Z		S   =>	Search execution start point			
Z									
Z		X   =>	Start point for ^X macros.			
Z									
Z		$   =>	Start point for ESC- macros.			
Z									
Z		$X  =>  Start point for ESC-X- macros.			
Z									
Z	Editor status word (QZN) bits:					
Z	Meaning if bit set						
Z									
Z		  32   =>	Enable macro collection			
Z									
Z		  16   =>	Inhibit screen update during cmd input	
Z									
Z		   8   =>	Primary output stream file is open	
Z									
Z		   4   =>	Primary input stream file is open	
Z									
Z		   2   =>	Current primary file has been modified	
Z									
Z		   1   =>	Append next kill to kill buffer 1	
Z
Z
Z!* START !
Z!* FIRST TEST TO SEE IF COMMAND STRING BEGAN WITH "EMACS"		!
Z
ZHK			!*Purge the buffer				!
ZGZ			!*Pull in the command line from QZT		!
ZJ			!*Jump back to beginning			!
Z@::S%EMA%		!*Test for command name starts with "EMA"	!
Z"U			!*If not successful then skip EMACS startup	!
Z  @O!BY!		!*Branch past EMACS boot			!
Z'			!*End of EMACS startup check			!
Z^D			!*Set radix to decimal				!
Z128,0ET			!*Reset abort on error bit			!
Z-1,5:W			!*Set terminal to hold whole screen		!
Z^[			!*Discard numeric argument returned by :W cmd	!
Z22,2:W			!*Protect the bottom 2 status lines from update	!
Z^[			!*Discard numeric argument returned by :W cmd	!
Z
Z!* Preload QHT with macro to erase a given line on screen, leave cursor	!
Z!* at that line, and make TECO forget it did anything to the terminal.	!
Z
Z@^UH~			!* QHT <= macro between the "~" s		!
Z  [A			!* Push QAT and QAN onto Q register stack	!
Z  UA			!* QAN <= input line number			!
Z  0,1ET			!* Enable image mode output			!
Z  27^T			!* Send escape to terminal			!
Z  ^^Y^T			!* Turn on direct access mode			!
Z  QA+31^T		!* Access line 1 through 24 (QA is 1...24)	!
Z  32^T			!* Access first column in the given line	!
Z  1,0ET			!* Disable image mode output			!
Z  ^^KMM			!* Kill the current lines contents		!
Z  32768W		!* Make TECO forget we messed with screen	!
Z  ]A			!* Pop QAT and QAN off the Q register stack	!
Z~			!* End of macro load into QHT			!
Z
Z!*Preload QMT with macro to output characters to terminal in image mode !
Z!*Q registers affected by an MM:  QAN					!
Z
Z@^UM~			!*QMT <= macro between "~" s  			!
Z  UA			!*QAN <= macro's argument (char to output) 	!
Z  0,1ET			!*Set image mode bit				!
Z  27^T			!*Send ESC to terminal for special sequence	!
Z  QA^T			!*Send the saved character to terminal		!
Z  1,0ET			!*Reset back to non image mode			!
Z~			!*End of image mode macro load in QMT		!
Z
Z!*Preload QUT with macro to optionally save a modified buffer		!
Z!*Q register affected by MU:  QLT, QAN, QST, QAN, QTN, QQN, QYN, QXN,	!
Z!*QWT									!
Z
Z@^UU~			!*QUT <= all characters between the "~" s	!
Z  <			!*Begin loop to save buffer			!
Z    @^UL%Save%		!*QLT <= "Save"					!
Z    @32:^UL%%		!*QLT <= "Save "				!
Z    @:^UL%modified%	!*QLT <= "Save modified"			!
Z    @32:^UL%%		!*QLT <= "Save modified "			!
Z    @:^UL%buffer%	!*QLT <= "Save modified buffer?"		!
Z    @32:^UL%%		!*QLT <= "Save modified buffer? "		!
Z    @:^UL%(Y/N)%	!*QLT <= "Save modified buffer? (Y/N)"		!
Z    MN			!*Get response from user			!
Z    UA			!*Save returned success/abort code		!
Z    QA;			!*Abort function if string fetch failed		!
Z    GS			!*Get the response string			!
Z    -1A-^^N"E		!*If response is "N" then			!
Z      -1UA		!*QAN <= code for successful execution		!
Z      HK		!*Purge the current buffer			!
Z      0;		!*Abort iteration and go to terminal code	!
Z    '			!*End of "N" processing				!
Z    -1A-^^Y"E		!*If response is "Y" then			!
Z      ^YK		!*Delete response from text buffer		!
Z      @^UL%File:%	!*QLT <= "File:"				!
Z      @32:^UL%%		!*QLT <= "File: "				!
Z      MN		!*Get response from user			!
Z      UA		!*Save returned success/abort code		!
Z      QA;		!*Abort function if string fetch failed		!
Z      @^UA%@EW/%	!*QAT <= "@EW/"					!
Z      GS		!*Pull file name string into buffer		!
Z      ^Y:XA		!*QAT <= "@EW/<filename>"			!
Z      ^YK		!*Delete from buffer in case we bomb		!
Z      @:^UA%/%		!*QAT <= "@EW/<filename>/"			!
Z      MA		!*Open the file to save current buffer in	!
Z      EC		!*Write out buffer and close file		!
Z      HK		!*Purge the buffer				!
Z      0;		!*Abort iteration and go to terminal code	!
Z    '			!*End of "Y" processing				!
Z    ^YK			!*Delete previous response from text buffer	!
Z  >			!*End loop to save buffer			!
ZQA			!*Return success code				!
Z~
Z
Z!*Preload QPT with macro to get next char from terminal stream		!
Z!*Q registers affected by MP: QTN, QYN, QXN, QQN			!
Z
Z@^UP~			!*QPT <= everything between "~" s		!
Z  0,32ET		!*Set read with no wait for pending commands	!
Z  ^TUT			!*QTN <= next pending command (-1 if none)	!
Z  QT"L			!*If no pending commands then			!
Z    32,0ET		!*Reset read with no wait bit to get user input	!
Z    16&QZ"E		!*If screen update is not inhibited then	!
Z      -1W		!*Update the terminal screen			!
Z    '			!*End of screen update test			!
Z    ^TUT		!*QTN <= next command from user			!
Z  '			!*End of no pending commands execution		!
Z  QT-7"E		!*If input from terminal is a ^G then		!
Z    0UY			!*Reset counter to exit current macro		!
Z    0UX			!*Reset counter to exit pending macros		!
Z    0UQ			!*Reset word to cause abort to highest level	!
Z  '			!*End of ^G from terminal processing		!
Z  QQ			!*Return ^G abort code as numerical argument	!
Z~			!*End of QPT macro load				!
Z
Z!* Preload QOT with macro to update editor status line (line 23)	!
Z
Z@^UO~			!* QOT <= all characters between the "~" s	!
Z  23MH			!* Go ready the editor status line		!
Z  @^A%EMACS11%		!* First entry on editor status line		!
Z  32^T			!* Send blank to terminal			!
Z  @^A%Ver%		!* Second entry on editor status line		!
Z  32^T			!* Send blank to terminal			!
Z  @^A%1.4%		!* Third entry on editor status line		!
Z  32^T			!* Send blank to terminal			!
Z  32^T			!* Send blank to terminal			!
Z  QZ&32"N		!* If LEARN mode is enabled then		!
Z    @^A%(Learn)%	!* Show learn prompt				!
Z  |			!* Else if not learn mode			!
Z    @^A%(Fundamental)%	!* Show fundamental mode			!
Z  '			!* End of mode entry on status line		!
Z  32^T			!* Send blank to terminal			!
Z  32^T			!* Send blank to terminal			!
Z  12&QZ"N		!* If a primary file is open then		!
Z    32^T		!* Send another blank to terminal		!
Z    @^A%File:%		!* Filespec is last entry on status line	!
Z    8&QZ"N		!* If primary output file stream is open then	!
Z      :GT		!* Get the output file spec			!
Z    |			!* Else input file must be open			!
Z      :GK		!* Get input file spec				!
Z    '			!* End of file spec test			!
Z  '			!* End of filespec insertion			!
Z  32768W		!* Forget we did anything to screen		!
Z~			!* End of status line update macro		!
Z
Z!*Preload QXT with macro to fetch next command character		!
Z!*Q registers affected by MX:  QTN, QYN, QXN, QQN, QWT,			!
Z
Z@^UX~			!*QXT <= all characters between the "~" s	!
Z  QY"E			!*If no EMACS macro commands to execute then	!
Z    MP			!*Get next command from command stream		!
Z    32&QZ"N		!*If learn mode is enabled then 		!
Z      @QT:^UW%%		!*Append the command to the macro buffer	!
Z    '			!*End of macro collection test			!
Z  '			!*End of no EMACS macro commands execution	!
Z  QY"L			!*If EMACS macro commands to execute then	!
Z    GW			!*Pull macro commands into buffer		!
Z    QYAUT		!*QTN <= EMACS command extracted from string	!
Z    ^YK			!*Kill string in buffer				!
Z    %Y			!*Increment macro command counter		!
Z    "E			!*If was last EMACS macro command then		!
Z      %X		!*Increment macro repeat counter		!
Z      "L		!*If more repeat loops to be done then		!
Z        -:QWUY		!*Restore command counter contents		!
Z      '			!*End of macro command counter restore		!
Z    '			!*End of last repeat loop test			!
Z  '			!*End of EMACS macro command fetch		!
Z  QQ			!*Return abort code as argument			!
Z~			!*End of QXT macro load				!
Z
Z!*Preload QNT with macro to input strings 				!
Z!*Q registers affected by MN: QST, QAN, QTN, QQN, QYN, QXN, QWT		!
Z
Z@^UN~			!*QNT <=  All characters between the "~" s	!
Z  0,0XS			!*QST <= null string (clear it)			!
Z  24MH			!*Go ready the prompt line			!
Z  :GL			!*Display prompt in QLT on terminal		!
Z  16#QZUZ		!*Set screen update inhibit bit			!
Z  -1UA			!*QAN <= no exit on esc value			!
Z  <			!*Begin infinite iteration to input string	!
Z    MX			!*QTN <= next character from command stream	!
Z    ;			!*If input was a ^G then abort function		!
Z    QT-10"N		!*If input was not line feed then		!
Z      QT^T		!*Echo character to terminal 			!
Z    '			!*End of scroll producing character trap	!
Z    @QT:^US%%		!*Append input character to QST string		!
Z    QT-10"E		!*If input was LF character then		!
Z      0;		!*Exit the input iteration			!
Z    '			!*End of LF execution 				!
Z    QT-127"E		!*If input was a "DELETE" character		!
Z      GS		!*Pull string into text buffer			!
Z      ^Y-1XS		!*Push back into QST minus "DELETE" character	!
Z      :QS"N		!*If not all characters deleted			!
Z        ^Y-2XS		!*Push back string minus char and "DELETE"	!
Z      '			!*End of non-null string character delete	!
Z      ^YK		!*Delete from text buffer			!
Z      24MH		!*Erase old prompt string			!
Z      :GL		!*Display prompt string				!
Z      :GS		!*Display current input string			!
Z      -1UA		!*QAN <= no double esc flag			!
Z      F<		!*Go get the next input				!
Z    '			!*End of DELETE character processing		!
Z    QT-27"E		!*If input was an ESC character then		!
Z      QA;		!*Exit input iteration if double ESC set	!
Z      0UA		!*Set to cause exit on next ESC			!
Z      F<		!*Go get the next input				!
Z    '			!*End of ESC input processing			!
Z    -1UA		!*QAN <= no double esc flag			!
Z  >			!*End of infinite iteration to input characters	!
Z  24MH			!*Erase the prompt line				!
Z  QQ"S			!*If successful string fetch then		!
Z    GS			!*Pull final string into text buffer		!
Z    ^Y-2XS		!*Strip off $$ or CRLF terminator		!
Z    ^YK			!*Delete from text buffer			!
Z  '			!*End of terminator removal			!
Z  16^_&QZUZ		!*Reset screen update inhibit bit		!
Z  QQ			!*Return success or failure code		!
Z~			!*End of string input macro			!
Z
Z!*LOAD TEXT Q REGISTER I WITH INFINITE ITERATION WHICH IS THE "ROOT"	!
Z!*OF THE EXECUTION COMMANDS						!
Z
Z@^UI~			!*QUI <= main editor macro between "~" char	!
Z  ^D			!*Set numeric radix to decimal			!
Z  225,30ET		!*No abort; attached; wait; not-image mode	!
Z			!*Cancel ^O; no-echo, lower-case; scope		!
Z  16ED			!*Yank prot; ^ means ctrl; srch	fail anchor	!
Z  16^_&QZUZ		!*Insure terminal update inhibit bit gets reset	!
Z  ^^HMM			!*Send cursor home				!
Z  ^^JMM			!*Clear entire screen				!
Z  MO			!*Update the status line			!
Z  32^T			!*Force TECO to update screen on next -1W cmd	!
Z  <			!*Begin edit execution macro 			!
Z    !A!			!*Label point 					!
Z    0UW			!*QWN <= 0 (Initialize up/down line loc save)	!
Z    !B!			!*Label point 					!
Z    -1UQ		!*QQN <= success  (reset abort value)		!
Z    1UO			!*QO <= 1 (Initialize repeat count) 		!
Z    16^_&QZUZ		!*Reset screen update inhibit bit		!
Z    MX			!*Get the next EMACS command			!
Z
Z!*BEGIN EXECUTION OF THE CURRENT COMMAND 				!
Z
Z    !V!			!*Start execution of command 			!
Z 
Z    QT@O/AI,CA,CB,CC,CD,CE,CF,CG,AI,AI,AI,CK,CL,AI,CN,CO,CP,CQ,CS,CS/
Z    QT-20@O/AI,AI,CV,CW,CX,CY,CZ,$/
Z
Z    QT-127"E		!*If command is a "delete" character then 	!
Z      QO<		!*Do by number of repeat counts			!
Z        -.;		!*Abort iteration if at buffer beginning	!
Z        -D		!*Delete back one character			!
Z      >			!*End of repeat iteration			!
Z      1^_&QZ#2UZ	!*No kill append; buffer modified		!
Z      F<		!**** Go get another user command 		!
Z    '			!*End of "delete" char execution 		!
Z
Z    !AI!		!*Auto insert the cmd char as text		!
Z    QO<QT@I%%>		!*Do an auto insert				!
Z    1^_&QZ#2UZ		!*No kill append; buffer modified		!
Z    F<			!**** Go get next command			!
Z
Z    !CA!		!*Begin ^A execution				!
Z    0L			!*Set pointer to beginning of current line	!
Z    1^_&QZUZ		!*No kill append;				!
Z    F<			!**** Go get another user command 		!
Z
Z    !CB!		!*Begin ^B execution				!
Z    QO<			!*Repeat by repeat count			!
Z      -.;		!*Exit iteration if at buffer beginning		!
Z      R			!*Backup one character				!
Z      >			!*End of repeat iteration			!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get another user command 		!
Z
Z    !CC!		!*Begin ^C execution				!
Z      0;		!*Return to teco level (can restart with MI) 	!
Z
Z    !CD!		!*Begin ^D execution				!
Z    QO<			!*Repeat by repeat count in QON			!
Z      .-Z;		!*Exit iteration if at buffer end		!
Z      D			!*Delete one character				!
Z    >			!*End of iteration				!
Z    1^_&QZ#2UZ		!*No kill append; buffer modified		!
Z    F<			!**** Go get next user command 			!
Z
Z    !CE!		!*Begin ^E execution				!
Z    L			!*Go to end of current line 			!
Z    ."N			!*If not at beginning of buffer then		!
Z      -1A-10"E		!*If previous character is a LF then		!
Z        2R		!*Back up over CRLF characters			!
Z      '			!*End of CRLF backover operation		!
Z    '			!*End of buffer beginning check			!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get next user command			!
Z 
Z    !CF!		!*Begin ^F execution				!
Z    QO<			!*Do by repeat count				!
Z      .-Z;		!*Exit iteration if at buffer end		!
Z      C			!*Go forward one character			!
Z    >			!*End of iteration				!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get next user command 			!
Z   
Z    !CG!		!*Begin ^G execution				!
Z    0UX			!*Abort any pending macro repeats		!
Z    0UY			!*Abort any pending commands in a current macro	!
Z    16#32^_&QZUZ	!*Reset screen inhibit and macro collection bits!
Z    7MM			!*Ring terminal's bell (no dirty thoughts now!)	!
Z    MO			!*Refresh status line				!
Z    F<			!**** Go get next user command			!
Z
Z    !CK!		!*Begin ^K execution				!
Z    QO<			!*Do the number of kills specified by repeat	!
Z      .-Z;		!*If at end of buffer then exit kill		!
Z      0AUA		!*QAN <= ascii code of next char in buffer	!
Z      QA-13"E		!*If it is a CR then kill the CRLF only		!
Z        QZ&1"N		!*If append bit is set then append kill 	!
Z          .,.+2:XZ	!*Append CRLF to kill buffer 1			!
Z        |		!*Else if append bit is not set then		!
Z          GZ		!*Pull kill buffer 1 contents into text buffer	!
Z          ^YXY		!*QTY <= second most recent kill		!
Z          ^YK		!*Delete second most recent kill from text buffr!
Z          .,.+2XZ	!*QTZ <= CRLF from end of line			!
Z          QZ#1UZ	!*Set the append bit for further kills		!
Z        '		!*End of CRLF kill in non-append mode		!
Z        2D		!*Delete CRLF from buffer			!
Z      |			!*Else if not at end of line then		!
Z        .-Z;		!*Exit the kill command if at buffer end	!
Z        .UA		!*Save current pointer position 		!
Z        L		!*Go to end of current line (after CRLF)	!
Z        -.;		!*If at top of buffer then exit kill command	!
Z        -1A-10"E	!*If previous char is LF then			!
Z          2R		!*Back up over CRLF 				!
Z        '		!*End of backup check				!
Z        QZ&1"N		!*If append bit is set then append kill		!
Z          QA,.:XZ	!*Append kill to buffer 1			!
Z        |		!*Else if append bit is not set then		!
Z          GZ		!*Pull kill buffer 1 contents into text buffer	!
Z          ^YXY		!*QTY <= second most recent kill		!
Z          ^YK		!*Delete second most recent kill from text buffr!
Z          QA,.XZ	!*QTZ <= current line up to CRLF		!
Z          QZ#1UZ	!*Set the append bit for further kills		!
Z        '		!*End of non-EOL non-append			!
Z        QA,.K		!*Kill the line up to CRLF			!
Z      '			!*End of non-EOL kill				!
Z    >			!*End of kill iteration				!
Z    2#QZUZ		!*Set buffer modified bit			!
Z    F<			!**** Go get next command 			!
Z    
Z    !CL!		!*Begin ^L execution				!
Z    ^^HMM		!*Send cursor to home position			!
Z    ^^JMM		!*Erase the entire screen (including last lines)!
Z    0,5:W		!*Turn off hold mode temporarily		!
Z    ^[			!*Discard numeric argument returned by :W cmd	!
Z    -1W			!*Update the screen				!
Z    -1,5:W		!*Turn hold mode back on			!
Z    MO			!*Put status line back in			!
Z    F<			!**** Go get next command			!
Z
Z    !CN!		!*Begin ^N execution				!
Z    1UA			!*Set up for down one line 			!
Z    @O!M!		!**** Go do the move 				!
Z   
Z    !CO!		!*Begin ^O execution				!
Z    QO<			!*Repeat by count 				!
Z      13@I%%		!*Insert a CR character 			!
Z      10@I%%		!*Insert a LF character 			!
Z      2R		!*Back up over the CRLF 			!
Z    >			!*End of repeat loop 				!
Z    1^_&QZ#2UZ		!*No kill append; buffer modified		!
Z    F<			!**** Go get next command 			!
Z   
Z    !CP!		!*Begin ^P execution				!
Z    -1UA		!*Set up for UP one line 			!
Z    !M!			!*^N and ^P move start label point 		!
Z    QO*QAUO		!*QON <= Number of lines to jump		!
Z    QW"E		!*If position # unknown from previous then	!
Z      0UD		!*QD <= zero					!
Z      .UA		!*QA <= current pointer loc 			!
Z      0L		!*Go to beginning of current line 		!
Z      QA-.%W<		!*Repeat for # of char to original pointer loc	!
Z        0A-32"L		!*If next buffer char is not printable char 	!
Z          0A-27"N	!*If next buffer char is not ESC then 		!
Z            0A-9"E	!*If next bffer char is a tab then 		!
Z              6-(QD&7)%W^[	!*					!
Z              -2UD	!*						!
Z            '		!*						!
Z            %D		!*Increment char counter			!
Z            1%W		!*Increment char loc for the "^" char		!
Z          '		!*End of non-ESC test				!
Z        '		!*End of non-printable test			!
Z        C		!*Move over one character			!
Z        %D		!*Increment character counter			!
Z      >			!*End of char location in line computation	!
Z    '			!*End of unknown location processing		!
Z    QOL			!*Go to start of destination line		!
Z    -QWUC		!*Initialize pointer location counter		!
Z    0UD			!*Clear character counter			!
Z    QW<			!*Begin iteration to go to character location	!
Z      .-Z;		!*If reached end of buffer then exit iteration	!
Z      0A-32"L		!*If next char is non-printable char then	!
Z        0A-13"E		!*If next char is also a CR then		!
Z          0;		!*Exit iteration; reached end of line		!
Z        '		!*End of CR processing 				!
Z        0A-27"N		!*If next char is NOT an ESC then		!
Z          0A-9"E	!*If next char is a TAB then			!
Z            6-(QD&7)%C^[!*						!
Z            -2UD	!*						!
Z          '		!*						!
Z          %D		!*Increment character counter			!
Z          1%C		!*Increment location counter			!
Z        '		!*End of non-ESC non-printable char processing	!
Z      '			!*End of non-printable char processing		!
Z      C			!*Move over one character in line		!
Z      %D		!*Increment character counter			!
Z      1%C		!*Increment location counter			!
Z      "G		!*If we over ran the location then		!
Z        R		!*Backup one character				!
Z      '			!*End of over run correction			!
Z      QC;		!*If have reached location then exit iteration	!
Z    >			!*End of new line move iteration		!
Z    1^_&QZUZ		!*No kill append				!
Z    @O!B!		!**** Go get next command			!
Z 
Z    !CQ!		!*Begin ^Q execution				!
Z    MX			!*Get the next input character 			!
Z    ^[			!*Discard any returned numeric value		!
Z    QO<			!*Repeat by count 				!
Z      QT@I%%		!*Insert the character 				!
Z    >			!*End of repeat loop 				!
Z    1^_&QZ#2UZ		!*No append of next kill; buffer modified	!
Z    F<			!**** Go get next command 			!
Z
Z    !CS!		!*Begin ^R or ^S execution			!
Z    QT-18"E		!*If command is ^R then				!
Z      -QOUO		!*Reverse search count				!
Z    '			!*End of search count negation for ^R command	!
Z    .UE			!*QEN <= original  pointer position		!
Z    0,0XA		!*QAT <= null string (initialize search string)	!
Z    <			!*Begin infinite search iteration loop		!
Z      MX		!*Get next command from command stream		!
Z      ^[		!*Discard any returned numeric value		!
Z      QT-7"E		!*If command is ^G then				!
Z        QEJ		!*Jump back to original pointer location	!
Z        24MH		!*Flush the current prompt line			!
Z        0;		!*Exit the search iteration			!
Z      '			!*End of ^G processing inside ^S loop		!
Z      QT-18"E		!*If input char is a ^R then			!
Z        :QA"E		!*If search string is null then			!
Z          GV		!*Pull previous successful search string in	!
Z          ^YXA		!*QAT <= previous search string			!
Z          ^YK		!*Delete string from text buffer		!
Z          @O!S!		!*Go search for new string			!
Z        |		!*Else if string is not null then		!
Z          .UF		!*QFN <= last successful search pointer loc	!
Z          @O!S2!	!*Go do search but start from current location	!
Z        '		!*End of non-null ^R processing			!
Z      '			!*End of ^R processing inside ^S loop		!
Z      QT-19"E		!*If input char is a ^S then			!
Z        :QA"E		!*If search string is null then			!
Z          GV		!*Pull previous successful search string in	!
Z          ^YXA		!*QAT <= previous search string			!
Z          ^YK		!*Delete string from text buffer		!
Z          @O!S!		!*Go search for new string			!
Z        |		!*Else if string is not null then		!
Z          .UF		!*QFN <= last successful search pointer loc	!
Z          @O!S2!	!*Go do search but start from current location	!
Z        '		!*End of non-null ^S processing			!
Z      '			!*End of ^S processing inside ^S loop		!
Z      QT-27"E		!*If input char is ESC then			!
Z        0;		!*Exit search loop				!
Z      '			!*End of ESC processing inside ^S loop		!
Z      QT-127"E		!*If  input is DELETE char then			!
Z        :QA"N		!*If search string is not null then		!
Z          GA		!*Pull string into text buffer			!
Z          ^Y-1XA	!*QAT <= truncated search string		!
Z          ^YK		!*Kill search string in text buffer		!
Z          24MH		!*Flush the current prompt line			!
Z        '		!*End of non-null DELETE processing		!
Z        @O!S!		!*Jump to search begin point			!
Z      '			!*End of DELETE char processing			!
Z      @QT:^UA%%		!*Append input character to QAT			!
Z      !S!		!*Search label point				!
Z      .UF		!*QFN <= last successful search pointer loc	!
Z      QEJ		!*Start search from original location		!
Z      !S2!		!*Label point for search starting from current	!
Z      16^_&QZUZ		!*Reset screen update inhibit bit		!
Z      QO:@S%^EQA%	!*Search for occurance specified by QON		!
Z      "U		!*If search was not successful then		!
Z        QFJ		!*Go back to last successful location		!
Z        24MH		!*Go ready the prompt line			!
Z        @^UB%Not%	!*QBT <= "Not"					!
Z        @32:^UB%%	!*QBT <= "Not "					!
Z        @:^UB%Found:%	!*QBT <= "Not Found:"				!
Z        @32:^UB%%	!*QBT <= "Not Found: "				!
Z        :GB		!*Show "Not Found: " to user			!
Z        :GA		!*Show search string to user			!
Z        32768W		!*Tell TECO to forget we messed with screen	!
Z        QY"N		!*If inside an EMACS macro then			!
Z          0UX		!*Flush macro repeat count to abort macros	!
Z          0UY		!*Abort any commands left in the current macro	!
Z          24MH		!*Flush the prompt line				!
Z          0;		!*Exit the search iteration			!
Z        |		!*Else if not inside macro			!
Z          16#QZUZ	!*Set terminal update inhibit bit		!
Z        '		!*End of EMACS macro test			!
Z      |			!*Else if the search was successful then	!
Z        QO"L		!*If search is reverse then			!
Z          .+^SJ		!*Jump to beginning of string			!
Z        '		!*End of reverse search pointer adjustment	!
Z        GA		!*Get the successful search string		!
Z        ^YXV		!*QVT <= most recent successful search string	!
Z        ^YK		!*Delete string from text buffer		!
Z        1^_&QZUZ	!*Reset append next kill bit			!
Z      '			!*End of search success test			!
Z    >			!*End of search loop				!
Z    16^_&QZUZ		!*Insure terminal update inhibit gets reset	!
Z    QE-."N		!*If final position is not same as initial then	!
Z      1^_&QZUZ		!*Reset append next kill bit			!    
Z    '			!*End of pointer movement test			!
Z    F<			!**** Go get next command			!
Z   
Z    !CV!		!*Begin ^V execution				!
Z    20*QOL		!*Jump down that many windows 			!
Z    1^_&QZUZ		!*No kill append				!
Z    F<			!**** Go get next command 			!
Z   
Z    !CW!		!*Begin ^W execution				!
Z    QZ&1"N		!*If append mode then				!
Z      QM,.:XZ		!*Append the marked region to kill buffer 1	!
Z    '			!*End of append					!
Z    QZ&1"E		!*If non-append mode then			!
Z      GZ		!*Pull kill buffer 1 contents into text buffer	!
Z      ^YXY		!*QTY <= second most recent kill		!
Z      ^YK		!*Delete second most recent kill from text buffr!
Z      QM,.XZ		!*QZT <= Currently marked region		!
Z      QZ#1UZ		!*Set append bit in QNZ				!
Z    '			!*End of non append kill save			!
Z    QM,.K		!*Kill from last mark to current point		!
Z    2#QZUZ		!*Mark buffer modified				!
Z    F<			!**** Go get next command 			!
Z   
Z    !CY!		!*Begin ^Y execution				!
Z    :QZ"N		!*If kill buffer length is not zero then	!
Z      QO<GZ>		!*Get current kill buffer 1 contents		!
Z      1^_&QZ#2UZ	!*No append on next kill; buffer modified	!
Z    '			!*End of unkill operation			!
Z    F<			!**** Go get next command 			!
Z
Z
Z!*ESC COMMAND MACROS START HERE 					!
Z   
Z    !$!			!*Begin input of 2nd char in 2 char cmd		!
Z    MX			!*Get 2nd char from user 			!
Z   
Z    ^[			!*Discard any returned numeric value		!
Z
Z    QT-7"E		!*If command is an ESC-^G then			!
Z      F<		!**** Go get next command			!
Z    '			!*End off ESC-^G execution			!
Z
Z    QT"D		!*If input was a numeric arg then 		!
Z      0UO		!*QO  <= 0  (clear repeat count) 		!
Z      16#QZUZ		!*Set inhibit screen update during input bit	!
Z      -1UA		!*QAN <= -1 (no loop exit)			!
Z      <			!*Begin infinite numeric fetch loop 		!
Z        QA;		!*Exit when input was not digit			!
Z        QO*10+QT-^^0UO	!*Build numeric value 				!
Z        MX		!*Get next char 				!
Z        ^[		!*Discard any returned numeric value		!
Z        QT-7"E		!*If input is ^G then				!
Z          1UO		!*Reset repeat count to 1			!
Z          0;		!*Exit the iteration				!
Z        '		!*End of ^G trap				!
Z        0UA		!*Set up to cause loop exit			!
Z        QT"D		!*If was a digit in then 			!
Z          -1UA		!*Set up to stay in loop			!
Z        '		!*End of digit test				!
Z      >			!*End of infinite numeric loop 			!
Z      16^_&QZUZ		!*Reset inhibit screen update during input bit	!
Z      @O!V!		!**** Go execute next command 			!
Z    '			!*End of numeric arg input 			!
Z   
Z    QT"V		!*If 2nd char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-^^X"E		!*If command is an ESC-X- command then		!
Z      @O!$X!		!**** Go to ESC-X macros			!
Z    '			!*End of ESC-X test				!
Z  	 
Z    QT-23"E		!*If command is ESC-^W then			!
Z      1#QZUZ		!*Append next kill to kill buffer		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-^W execution			!
Z
Z    QT-25"E		!*If command is ESC ^Y then			!
Z      G9		!*Yank in the TECO minibuffer contents		!
Z      1^_&QZ#2UZ	!*No append next kill; buffer modified		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC ^Y execution			!
Z
Z    QT-27"E		!*If command is ESC-ESC then 			!
Z      @^UL%Command:%	!*QLT <= Minibuffer prompt 			!
Z      @32:^UL%%		!*QLT <= "Command: "				!
Z      MN		!*Get input string from user			!
Z      "U		!*If string fetch was unsuccessful then 	!
Z        32768W		!*Tell TECO to forget we fiddled with screen	!
Z        F<		!**** Go get next command			!
Z      '			!*End of fetch failed test			!
Z      GS		!*Pull string into buffer			!
Z      ^YXQ		!*Push string into QQT				!
Z      ^YK		!*Delete string from buffer			!
Z      @27:^UQ%%		!*Append ESC to QQT				!
Z      @27:^UQ%%		!*Append ESC to QQT				!
Z      MQ		!*Execute TECO command				!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-ESC command execution 		!
Z   
Z   QT-^^B"E		!*If command is ESC-B then			!
Z      QO<		!*Do according to repeat count			!
Z        .UA		!*Save current pointer				!
Z        @0,-1:S%^ES%	!*Scan backwards for tabs & blanks		!
Z        "U		!*If unsuccessful then				!
Z          J		!*Jump to beginning of buffer			!
Z          0;		!*Exit the iteration				!
Z        '		!*End "no more" test				!
Z        .-QA+1"G	!*If pointer didn't move backwards then		!
Z          <		!*Begin  iteration to move pointer back		!
Z            -.;		!*Done if at beginning				!
Z            R		!*Back up one character				!
Z            -.;		!*Done if at beginning				!
Z            0A-32"N	!*If not a blank then				!
Z              0A-9"N	!*If not a tab then				!
Z                0A-13"N	!*If not a CR then				!
Z                  0A-10"N	!*If not a LF then			!
Z                    0;	!*Backup is done				!
Z                  '	!*End of LF test				!
Z                '	!*End of CR test				!
Z              '		!*End of TAB test				!
Z            '		!*End of BLANK test				!
Z          >		!*End of backup iteration			!
Z          @0,-1:S%^ES%	!*Scan for 2nd occurance backwards		!
Z          "U		!*If unsuccessful then				!
Z            J		!*Jump to buffer beginning			!
Z          '		!*End of no 2nd occurance test			!
Z        '		!*End of pointer didn't move test		!
Z      >			!*End of ESC-B iteration			!
Z      1^_&QZUZ		!*No append for next kill			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-B command execution		!
Z   
Z    QT-^^F"E		!*If command is ESC-F then			!
Z      QO<		!*Do according to repeat count			!
Z        .UA		!*QAN <= current pointer position		!
Z        @0,1:S%^EL%	!*Look for next line terminator			!
Z        .UB		!*QBN <= possible line terminator pntr		!
Z        QAJ		!*Return to original location			!
Z        @0,1:S%^ES%	!*Scan rest of buffer for tabs & blanks		!
Z        .UC		!*QCN <= possible tab/blank string pntr		!
Z        QB-QA"G		!*If line terminator was also found		!
Z          QC-QB"G	!*If line terminator was first then		!
Z            QBJ		!*Go to it instead				!
Z          '		!*End of line term first test			!
Z        '		!*End of line term also found test		!
Z        .-QA"E		!*If no move was made then			!
Z          0;		!*Exit the iteration if no more			!
Z        '		!*End of no more moves test			!
Z      >			!*End of ESC-F iteration			!
Z      1^_&QZUZ		!*No append for next kill			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC-F command execution		!
Z   
Z    QT-^^G"E		!*If command is ESC G then			!
Z      .UA		!*Save initial pointer location			!
Z      J			!*Jump to buffer beginning			!
Z      QO-1L		!*Go down specified number of lines-1		!
Z      QA-."N		!*If not back where we started then		!
Z        1^_&QZUZ	!*No append next kill				!
Z      '			!*End of pointer movement test			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC G command				!
Z
Z    QT-^^N"E		!*If command is ESC-N then 			!
Z      QOP		!*Jump to that page 				!
Z      1^_&QZUZ		!*No kill append				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-N command execution 		!
Z   
Z    QT-^^V"E		!*If command is ESC-V then 			!
Z      -20*QOL		!*Jump back up that many windows 		!
Z      1^_&QZUZ		!*No kill append				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-V command execution 		!
Z 
Z    QT-^^W"E		!*If command is a ESC-W then			!
Z      GZ		!*Pull kill buffer 1 contents into text buffer	!
Z      ^YXY		!*QTY <= second most recent kill		!
Z      ^YK		!*Delete second most recent kill from text buffr!
Z      QM-."G		!*If mark is ahead of pointer then		!
Z        .,QMXZ		!*QZT <= region from pointer+1 to mark		!
Z      |			!*Else if mark is behind pointer then		!
Z        QM,.XZ		!*QZT <= region from mark+1 to pointer		!
Z      '			!*End of mark+1 to pointer region save		!
Z      1^_&QZUZ		!*Set no append					!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-W execution 			!
Z
Z    QT-^^Z"E		!*If command is ESC-Z then			!
Z      0;		!*Exit to teco level				!
Z   '			!*End of ESC-Z command execution		!
Z   
Z    QT-^^%"E		!*If command is ESC % then			!
Z      1UB		!*Enable query					!
Z      !QR!		!*Query replace / replace common point		!
Z      @^UL%Replace:%	!*QLT <= "Replace:"				!
Z      @32:^UL%%		!*QLT <= "Replace: "				!
Z      MN		!*Get the input string				!
Z      "U		!*If failed then				!
Z        F<		!**** Go get next command			!
Z      '			!*End of string fetch abort test		!
Z      GS		!*Get the string that was input			!
Z      ^YXA		!*QAT <= string to replace			!
Z      ^YK		!*Delete string from buffer			!
Z      @^UL%With:%	!*QLT <= "With:"				!
Z      @32:^UL%%		!*QLT <= "With: "				!
Z      MN		!*Get the input string				!
Z      "U		!*If failed then				!
Z        F<		!**** Go get next command			!
Z      '			!*End of string fetch abort test		!
Z      <			!*Begin query replace loop			!
Z        0,1:@S%^EQA%	!*Find string to replace			!
Z        ;		!*If search failed then exit			!
Z        1^_&QZUZ	!*Reset append next kill bit since pointer moved!
Z        32UT		!*Fake a confirm by user			!
Z        QB"N		!*If query is enabled then			!
Z          MP		!*Get response from terminal stream		!
Z          ;		!*If abort then exit loop			!
Z        '		!*End of user query				!
Z        QT-32"E		!*If space bar was pressed then			!
Z          ^YK		!*Kill the last found string			!
Z           GS		!*Replace with replacement string		!
Z           2#QZUZ	!*Set buffer modified bit			!
Z           1^_&QZUZ	!*Reset append next kill bit			!
Z        '		!*End of positive replacement response test	!
Z      >			!*End of query replace loop			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC % command processing		!
Z
Z    QT-^^*"E		!*If command is ESC * then			!
Z      :QQ"N		!*If length of last TECO cmd is not zero then	!
Z        ^^HMM		!*Send cursor to home position			!
Z        ^^JMM		!*Clear the screen				!
Z        :GQ		!*Show the contents of the TECO minibuffer	!
Z        16#QZUZ		!*Disable screen update during command fetch	!
Z        MX		!*Get the next command character (ignored)	!
Z        ^[		!*Discard any returned numeric value		!
Z        16^_&QZUZ	!*Enable screen updates again			!
Z        MO		!*Refresh the status line			!
Z        32^T		!*Force TECO to update screen			!
Z      '			!*End of non null TECO cmd processing		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC * command execution		!
Z
Z    QT-^^<"E		!*If command is ESC-< then 			!
Z      0J		!*Jump to top of buffer 			!
Z      1^_&QZUZ		!*No kill append 				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-< command execution 		!
Z   
Z    QT-^^>"E		!*If command is ESC-> then 			!
Z      ZJ		!*Jump to end of buffer 			!
Z      1^_&QZUZ		!*No kill append 				!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-> command execution 		!
Z   
Z    QT-^^@"E		!*If command is ESC-@ then 			!
Z      .UM		!*Set mark at current point 			!
Z      24MH		!*Go ready the prompt line			!
Z      @^A%Set.%		!*Tell user mark is set				!
Z      32768W		!*Tell TECO to forget we messed with screen	!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ESC-@ command execution 		!
Z   
Z    7MM			!*ESC command not found; ring bell 		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command 			!
Z
Z
Z!*^X  COMMAND MACROS 							!
Z
Z    !CX!		!*^X commands start here 			!
Z    MX			!*Get the 2nd char in the ^X command 		!
Z   
Z   ^[			!*Discard any returned numeric value		!
Z
Z    QT-7"E		!*If command is an ^X-^G then			!
Z      F<		!**** Go get next command			!
Z    '			!*End off ^X-^G execution			!
Z
Z    QT"V		!*If 2nd char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-12"E		!*If command is ^X ^L then			!
Z      .UC		!*QCN <= current pointer location		!
Z      QMUA		!*QAN <= Region start (mark location initially)	!
Z      .UB		!*QBN <= Region end (pointer loc initially)	!
Z      QB-QA"L		!*If mark is after pointer then			!
Z        QMUB		!*QBN <= mark location				!
Z        .UA		!*QAN <= pointer location			!
Z      '			!*End of mark/pointer reversal			!
Z      QAJ		!*Jump to start of region			!
Z      QB-QA<		!*For number of characters in region		!
Z        0A"W		!*If next character is uppercase then		!
Z          0A+32@I%%	!*Insert matching lower case character		!
Z          D		!*Delete the uppercase character		!
Z          R		!*Back up over the new lower case character	!
Z          2#QZUZ	!*Set buffer modified bit			!
Z        '		!*End of case conversion			!
Z        C		!*Go check next character			!
Z      >			!*End of case conversion			!
Z      QCJ		!*Jump back to start location			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X ^L processing			!
Z
Z    QT-14"E		!*If command is ^X ^N then			!
Z      6:W-1UA		!*QAN <= buffer loc of char before home position!
Z      QA"N		!*If home position is not top of buffer then	!
Z        8&QZ"N		!*If output file is open then			!
Z          B,QAP		!*Output from top to home to output file	!
Z          .-QAUE	!*Adjust pointer to current loc BEFORE delete	!
Z          B,QAD		!*Delete from buffer				!
Z          QEJ		!*Jump to adjusted buffer loc (same rel pos)	!
Z          ^E"N		!*If previous read found form feed then		!
Z            ZJ		!*Jump to buffer end				!
Z            12@I%%	!*Insert a form feed character			!
Z            QEJ		!*Jump back to original location		!
Z          '		!*End of form feed append if necessary		!
Z          A		!*Append a new page to current page		!
Z        '		!*End of output file open processing		!
Z      '			!*End of across page boundry append		!
Z    1^_&QZUZ		!*No append next kill				!
Z    F<			!**** Go get next command			!
Z    '			!*End of ^X^N processing			!
Z
Z    QT-18"E		!*If command is ^X-^R then			!
Z      @^UL%Read%	!*QLT <= "Read"					!
Z      @32:^UL%%		!*QLT <= "Read "				!
Z      @:^UL%file:%	!*QLT <= "Read file:"				!
Z      @32:^UL%%		!*QLT <= "Read file: "				!
Z      MN		!*Go get input string				!
Z      "U		!*If string fetch was unsuccessful then		!
Z        F<		!**** Go get next command			!
Z      '			!*End of zero-length string test		!
Z      GS		!*Pull file string into buffer			!
Z      ^YXB		!*Put in QBT for safe keeping			!
Z      ^YK		!*Purge from buffer				!
Z      8&QZ"N		!*If output file is open then			!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          EC		!*Move buffer to file and close file		!
Z        |		!*Else if buffer has not been modified then	!
Z          EK		!*Kill the output file				!
Z        '		!*End of output file open processing		!
Z      |			!*Else if output file is not open then		!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          MU		!*Take action to save the buffer or delete it	!
Z          "U		!*If aborted then				!
Z            F<		!**** Go get next command			!
Z          '		!*End of abort trap				!
Z        '		!*End of buffer modified processing		!
Z      '			!*End of output file open/closed processing	!
Z      2#8^_&QZUZ	!*Reset modified and output file open bits	!
Z      @^UA%@:ER/%	!*QTA <= all characters between "%" s		!
Z      GB		!*Get the file string				!
Z      ^Y:XA		!*Append it to EB command			!
Z      @:^UA%/%		!*Append all char between "%" s to QTA		!
Z      HK		!*Purge current buffer				!
Z      4^_&QZUZ		!*Reset input file open bit			!
Z      MA		!*Try to open an old file for read only		!
Z      "S		!*If successful open then			!
Z        G*		!*Pull file file-spec into buffer		!
Z        ^YXK		!*QKT <= primary input filespec			!
Z        HK		!*Purge buffer					!
Z        A		!*Pull in first page of the file		!
Z        4#QZUZ		!*Set input file open 				!
Z      '			!*End of successful open execution		!
Z      1#2^_&QZUZ	!*No kill append; buffer not modified		!
Z      MO		!*Update the status line			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-^R execution			!
Z
Z    QT-19"E		!*If command is ^X ^S then			!
Z      8&QZ"N		!*If output file is open then			!
Z        EC		!*Move out rest of input file and close output	!
Z        2#8^_&QZUZ	!*Reset modified and output file open bits	!
Z        @^UA%@EB/%	!*QAT <= "@EB/"					!
Z        GT		!*Pull output file spec into text buffer	!
Z        ^S+.J		!*Jump back to beginning of string (revs bug)	!
Z        .UA		!*QAN <=  loc before first filespec character	!
Z	@S%;%		!*Search FORWARD for first ; character		!
Z        QA,.-1:XA	!*Append filename minus the version number	!
Z        @:^UA%/%	!*QAT <= "@EB/<filename>/"			!
Z        HK		!*Purge current buffer				!
Z        MA		!*Open the previous file for both input & output!
Z        G*		!*Get the new file spec				!
Z        ^YXT		!*QTT <= new output file spec			!
Z        ^YXK		!*QKT <= new input file spec			!
Z        HKA		!*Purge buffer and pull  in first page of file	!
Z        1#4#8#QZUZ	!*No kill append, output and input files open	!
Z      '			!*End of file save for open output file		!
Z      MO		!*Update the status line to show new filename	!
Z      F<		!**** Go get next command			!
Z    '			!* End of ^X ^S execution			!
Z
Z    QT-21"E		!*If command is ^X ^U then			!
Z      .UC		!*QCN <= current pointer location		!
Z      QMUA		!*QAN <= Region start (mark location initially)	!
Z      .UB		!*QBN <= Region end (pointer loc initially)	!
Z      QB-QA"L		!*If mark is after pointer then			!
Z        QMUB		!*QBN <= mark location				!
Z        .UA		!*QAN <= pointer location			!
Z      '			!*End of mark/pointer reversal			!
Z      QAJ		!*Jump to start of region			!
Z      QB-QA<		!*For number of characters in region		!
Z        0A"V		!*If next character is lowercase then		!
Z          0A-32@I%%	!*Insert matching uppercase character		!
Z          D		!*Delete the lowercase character		!
Z          R		!*Back up over the new uppercase character	!
Z          2#QZUZ	!*Buffer modified				!
Z        '		!*End of case conversion			!
Z        C		!*Go look at next character			!
Z      >			!*End of case conversion			!
Z      QCJ		!*Jump back to start location			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X ^U processing			!
Z
Z    QT-22"E		!*If command is ^X-^V then			!
Z      @^UL%Visit%	!*QLT <= "Visit"				!
Z      @32:^UL%%		!*QLT <= "Visit "				!
Z      @:^UL%file:%	!*QLT <= "Visit file:"				!
Z      @32:^UL%%		!*QLT <= "Visit file: "				!
Z      MN		!*Go get input string				!
Z      "U		!*If string fetch was unsuccessful then		!
Z        F<		!**** Go get next command			!
Z      '			!*End of zero-length string test		!
Z      GS		!*Pull file string into buffer			!
Z      ^YXB		!*Put in QBT for safe keeping			!
Z      ^YK		!*Purge from buffer				!
Z      8&QZ"N		!*If output file is open then			!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          EC		!*Move the new buffer to output file & close it	!
Z        |		!*Else if buffer has not been modified then	!
Z          EK		!*Kill the output file				!
Z        '		!*End of kill unmodified buffer & kill file	!
Z      |			!*Else  if output file is not open then		!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          MU		!*Take action to save the buffer		!
Z          "U		!*If aborted then				!
Z            F<		!**** Go get next command			!
Z          '		!*End of abort trap				!
Z        '		!*End of buffer modified processing		!
Z      '			!*End of output file is open/closed processing	!
Z      2#8^_&QZUZ	!*Reset modified and output file open bits	!
Z      @^UA%@:EB/%	!*QTA <= all characters between "%" s		!
Z      GB		!*Get the file string				!
Z      ^Y:XA		!*Append it to EB command			!
Z      @:^UA%/%		!*Append all char between "%" s to QTA		!
Z      HK		!*Purge buffer					!
Z      MA		!*Try to open an old file with backup		!
Z      "S		!*If successful open then			!
Z        G*		!*Pull complete filespec into buffer		!
Z        ^YXT		!*QTT <= new output filespec			!
Z        ^YXK		!*QKT <= new input filespec			!
Z        HKA		!*Kill current buffer and pull in next		!
Z        4#8#QZUZ	!*Set input file open & output file open bit	!
Z      |			!*Else if not successful open with backup then	!
Z        @^UA%@EW/%	!*QTA <= all char between "%" s 		!
Z        GS		!*Pull file name back into buffer		!
Z        ^Y:XA		!*Append the file string to QTA			!
Z        ^YK		!*Kill file name in case it bombs		!
Z        @:^UA%/%	!*Append the final commands to QTA		!
Z        MA		!*Open a new file				!
Z        G*		!*Pull output filespec into buffer		!
Z        ^YXT		!*QTT <= new output file spec			!
Z        HK		!*Purge the buffer				!
Z        8#QZUZ		!*Set output file open bit			!
Z      '			!*End of open file execution			!
Z      1#2^_&QZUZ	!*No kill append; buffer not modified		!
Z      MO		!*Update status line				!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-^V execution			!
Z
Z    QT-23"E		!*If command is ^X-^W then			!
Z      @^UL%Write%	!*QLT <= "Write"				!
Z      @32:^UL%%		!*QLT <= "Write "				!
Z      @:^UL%file:%	!*QLT <= "Write file:"				!
Z      @32:^UL%%		!*QLT <= "Write file: "				!
Z      MN		!*Go get input string				!
Z      "U		!*If string fetch was unsuccessful then		!
Z        F<		!**** Go get next command			!
Z      '			!*End of zero-length string test		!
Z      8&QZ"N		!*If output file is open then			!
Z        EF		!*Close the output file with no output		!
Z        8^_&QZUZ	!*Reset output file open bit			!
Z      '			!*End of output file is open processing		!
Z      @^UA%@:EW/%	!*QTA <= all characters between "%" s		!
Z      GS		!*Get the file string				!
Z      ^Y:XA		!*Append it to EW command			!
Z      ^YK		!*Delete file string from text buffer		!
Z      @:^UA%/%		!*Append all char between "%" s to QTA		!
Z      MA		!*Open a new output file			!
Z      "S		!*If successful open then			!
Z        G*		!*Pull in complete file spec			!
Z        ^YXT		!*QTT <= output filespec			!
Z        ^YK		!*Kill filespec from buffer			!
Z        2#8#QZUZ	!*Mark as modified; output file open		!
Z      '			!*End of open success test			!
Z      MO		!*Update  the status line			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-^W execution			!
Z
Z    QT-24"E		!*If command is a ^X-^X then 			!
Z      .UN		!*QN <= current pointer loc (next mark) 	!
Z      QMJ		!*Jump to marked position 			!
Z      QNUM		!*Set mark at previous pointer loc 		!
Z      1^_&QZUZ		!*No kill append 				!
Z      F<		!**** Go get next user command 			!
Z    '			!*End of ^X-^X command execution 		!
Z   
Z    QT-27"E		!*If command is ^X-ESC then 			!
Z      MQ		!*Re-execute TECO macro in Q9			!
Z      F<		!**** Go get next command 			!
Z    '			!*End of ^X-ESC command execution 		!
Z   
Z    QT-^^A"E		!*If command is ^X A then			!
Z      4&QZ"N		!*If input file is open then			!
Z        ^E"N		!*If previous read found a form feed then	!
Z          .UA		!*QAN <= current pointer position		!
Z          ZJ		!*Jump to end of buffer				!
Z          12@I%%	!*Insert a form feed				!
Z          QAJ		!*Jump back to original point			!
Z        '		!*End of form feed append if necessary		!
Z        A		!*Append from input file			!
Z      '			!*End of append					!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X A command execution			!
Z
Z    QT-^^E"E		!*If command is ^X-E then			!
Z      -:QWUY		!*Initialize up-counter for # of commands	!
Z      -QOUX		!*Initialize macro repeat count			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-E execution				!
Z
Z   QT-^^N"E		!*If command is ^XN then			!
Z      .UE		!*QEN <= Current pointer location		!
Z      MR		!*Get cursor line number			!
Z      -1UB		!*QBT <= # lines to get to home position	!
Z      -QBL		!*Jump to start of first line on screen		!
Z      .UA		!*QAN <= Char pointer value at home position	!
Z      QEJ		!*Jump back to original location		!
Z      QA"N		!*If home position is not top of buffer then	!
Z        8&QZ"N		!*If output file is open then			!
Z          .-QAUE	!*Adjust pointer to current location before del	!
Z          B,QAP		!*Output from top to home to output file	!
Z          B,QAD		!*Delete from buffer				!
Z          QEJ		!*Go to original location			!
Z        '		!*End of output file open processing		!
Z      '			!*End of make room execution			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^XN processing				!
Z
Z    QT-^^Q"E		!*If command is ^X-Q then			!
Z      QY"L		!*If macro command fetch in progress then	!
Z        MP		!*Get next command from terminal stream only	!
Z        QQ"E		!*If response is ^G then			!
Z          F<		!**** Go get next command			!
Z        '		!*End of ^G response processing			!
Z        QT-32"N		!*If next input is not space char then		!
Z          0UY		!*Set macro fetch counter to zero to force exit	!
Z          %X		!*Increment macro repeat counter		!
Z          "L		!*If more macro loops left to be done then	!
Z            -:QWUY	!*Restore command counter contents		!
Z          '		!*End of macro command counter restore		!
Z        '		!*End of macro abort test			!
Z      '			!*End of macro command query operation		!
Z      F<		!**** go get next command			!
Z    '			!*End of ^X-Q execution				!
Z
Z    QT-^^T"E		!*If command is ^X T then			!
Z      QY"L		!*If macro command fetch in progress then	!
Z        -1W		!*Update terminal screen			!
Z      '			!*End of commmand fetch in progress execution	!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X T execution				!
Z
Z    QT-^^*"E		!*If command is ^X-*				!
Z      :QW"N		!*If macro string is not null then		!
Z        ^^HMM		!*Send cursor home				!
Z        ^^JMM		!*Clear the screen				!
Z        :GW		!*Show user the current macro string		!
Z        16#QZUZ		!*Inhibit screen update				!
Z        MX		!*Get the next character			!
Z        ^[		!*Discard any returned numeric value		!
Z        16^_&QZUZ	!*Reset screen update inhibit bit		!
Z        MO		!*Refresh the status line			!
Z        32^T		!*Force TECO to update screen			!
Z      '			!*End of non null macro string processing	!
Z      F<		!**** Go get next command			!
Z    '			!*End of X-* processing				!
Z
Z    QT-^^("E		!*If command is ^X-( then			!
Z      32#QZUZ		!*Set macro collection bit in control word	!
Z      0,0XW		!*Purge previous macro (if any)			!
Z      MO		!*Update the status line			!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-( execution				!
Z
Z    QT-^^)"E		!*If command is ^X-) then			!
Z      32&QZ"N		!*If macro collection bit is set		!
Z        GW		!*Get the current EMACS macro			!
Z        ^Y-2XW		!*Push back minus the ^X and ) char		!
Z        ^YK		!*Delete from text buffer			!
Z        32^_&QZUZ	!*Reset macro collection bit in control word	!
Z        MO		!*Update the status line			!
Z      '			!*End of macro collection termination		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X-) execution				!
Z
Z    QT-^^="E		!*If command is ^X = then			!
Z      .UA		!*QAN <= current pointer position		!
Z      J			!*Jump to beginning of buffer			!
Z      1UB		!*QBN <= initial line number			!
Z      <			!*Start line count iteration			!
Z        L		!*Go down one line				!
Z        .-QA;		!*If past original start point then exit iter	!
Z        %B		!*Increment the line count			!
Z      >			!*End of line count iteration			!
Z      ."G		!*If buffer is not empty then			!
Z        .-QA"E		!*If at original start point then		!
Z          -1A-10"E	!*If previous character is a LF then		!
Z            %B		!*Increment the line count again		!
Z          '		!*End of CRLF test				!
Z        '		!*End of past start point test			!
Z      '			!*End of buffer not empty test			!
Z      QAJ		!*Jump back to original start point		!
Z      0L		!*Go to start of that line			!
Z      QA-.UC		!*QCN <= number of characters over		!
Z      QAJ		!*Jump back to original start point		!
Z      ^^HMM		!*Send cursor to home position			!
Z      ^^JMM		!*Clear the screen				!
Z      @^A%Line%		!*Show line number header			!
Z      32^T		!*Send blank to terminal			!
Z      QB=		!*Show value to user				!
Z      @^A%After%	!*Send char number header			!
Z      32^T		!*Send blank to terminal			!
Z      @^A%character%	!*Send rest of char number header		!
Z      32^T		!*Send another blank to terminal		!
Z      QC=		!*Show value to user				!
Z      16#QZUZ		!*Inhibit screen update during next cmd fetch	!
Z      MX		!*Get next char from command stream (ignored)	!
Z      ^[		!*Discard any returned numeric value		!
Z      16^_QZUZ		!*Enable screen updates again			!
Z      MO		!*Refresh the status line			!
Z      32^T		!*Force TECO to update screen on next -1W	!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^X = command execution			!
Z
Z    7MM			!*^X command not found; ring bell 		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command 			!
Z
Z
Z!* ESC-X MACROS START HERE						!
Z   
Z    !$X!		!*Begin ESC-X macros				!
Z    MX			!*Get next command character			!
Z
Z    ^[			!*Discard any returned numeric value		!
Z
Z    QT"V		!*If char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-7"E		!*If command is an ESC-X-^G then		!
Z      F<		!**** Go get next command			!
Z    '			!*End off ESC-X-^G execution			!
Z
Z    QT-^^C"E		!*If command is an ESC X C then			!
Z      3:W"E		!*If see-all mode is off then			!
Z        1,3:W		!*Turn see-all mode on				!
Z      |			!*Else if see-all mode is on then		!
Z        0,3:W		!*Turn see-all mode off				!
Z      '			!*End of see-all state flip-flop		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X C processing			!
Z
Z    QT-^^D"E		!*If command is an ESC X D then			!
Z      ^BUA		!*QAN <= code for current date			!
Z      QA/512UB		!*QBN <= current year				!
Z      QA-(QB*512)/32UC	!*QCN <= current month				!
Z      QA-(QA/32*32)UD	!*QDN <= current day				!
Z      QC-10"L		!*If month is less than 10 then			!
Z        @I%0%		!*Insert a leading 0 in text buffer		!
Z      '			!*End of leading zero insertion			!
Z      QC\		!*Insert month in text buffer			!
Z      @I%-%		!*Insert "-" character in text buffer		!
Z      QD-10"L		!*If day is less than 10 then			!
Z        @I%0%		!*Insert a leading zero				!
Z      '			!*End of leading zero insertion			!
Z      QD\		!*Insert day in text buffer			!
Z      @I%-%		!*Insert a "-" in text buffer			!
Z      QB-10"L		!*If year is less than 10 then			!
Z        @I%0%		!*Insert a "0" in text buffer			!
Z      '			!*End of leading zero insertion			!
Z      QB\		!*Insert year in text buffer			!
Z      1^_&QZ#2UZ	!*No append next kill; buffer modified		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X D execution			!
Z
Z    QT-^^O"E		!*If command is an ESC X O then			!
Z      @^UL%String:%	!*QLT <= "String:"				!
Z      @32:^UL%%		!*QLT <= "String: "				!
Z      MN		!*Get the search string				!
Z      "U		!*If string fetch failed then			!
Z        32768W		!*Tell TECO to forget we fiddled with screen	!
Z        F<		!**** Go get next command			!
Z      '			!*End of fetch failed trap			!
Z      .UE		!*Save current buffer pointer			!
Z      @:S%^EQS%		!*Find an occurance of string (if any)		!
Z      "S		!*If there is at least one then			!
Z        ^^HMM		!*Send cursor home				!
Z        ^^JMM		!*Erase screen					!
Z        <		!*Begin iteration to display occurances		!
Z          0L		!*Go to start of line containing occurance	!
Z          T		!*Show line to user				!
Z          L		!*Resume search at next line			!
Z          @:S%%		!*Look for next occurance			!
Z          ;		!*Exit iteration when no more found		!
Z        >		!*End of search & show loop			!
Z        QEJ		!*Return to original location			!
Z        16#QZUZ		!*Inhibit screen update during input		!
Z        MX		!*Get next character from input stream		!
Z        ^[		!*Discard any returned numeric value		!
Z        16^_&QZUZ	!*Enable screen updates again			!
Z        MO		!*Refresh status line				!
Z        32^T		!*Force TECO to update screen on next -1W	!
Z      '			!*End of occurances display when string found	!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X O processing			!
Z
Z    QT-^^R"E		!*If command is an ESC X R 			!
Z      0UB		!*Disable query					!
Z      @O!QR!		!*Jump to query replace / replace common	!
Z    '			!*End of ESC X R processing			!
Z
Z    QT-^^T"E		!*If command is an ESC X T then			!
Z      ^HUA		!*QAN <= # seconds since midnight / 2		!
Z      QA/1800UB		!*QBN <= # hours since midnight			!
Z      QA-(QB*1800)/30UC	!*QCN <= # minutes in current hour		!
Z      QA-(QA/30*30)*2UD	!*QDN <= # seconds in current minute		!
Z      QB-10"L		!*If # hours is less than 10 then		!
Z        @I%0%		!*Insert a "0" in text buffer			!
Z      '			!*End of leading zero insertion			!
Z      QB\		!*Insert # hours in text buffer			!
Z      @I%:%		!*Insert a ":" in text buffer			!
Z      QC-10"L		!*If # minutes is less than 10 then		!
Z        @I%0%		!*Insert a leading 0 in text buffer		!
Z      '			!*End of leading zero insertion			!
Z      QC\		!*Insert # minutes in text buffer		!
Z      @I%:%		!*Insert ":" character in text buffer		!
Z      QD-10"L		!*If # seconds is less than 10 then		!
Z        @I%0%		!*Insert a leading zero				!
Z      '			!*End of leading zero insertion			!
Z      QD\		!*Insert # seconds in text buffer		!
Z      1^_&QZ#2UZ	!*No append next kill; buffer modified		!
Z      F<		!**** Go get next command			!
Z    '			!*End of ESC X T execution			!
Z
Z    7MM			!*ESC-X command not found; ring bell		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command			!
Z
Z
Z!*^Z MACROS START HERE							!
Z   
Z    !CZ!		!*Begin ^Z macros				!
Z    MX			!*Get next command character			!
Z   
Z    ^[			!*Discard any returned numeric value		!
Z
Z    QT"V		!*If 2nd char is lower case alpha then 		!
Z      QT-32UT		!*Convert to upper case 			!
Z    '			!*End of case conversion 			!
Z   
Z    QT-6"E		!*If command is ^Z-^F then			!
Z      GT		!*Get filename 					!
Z      1^_&QZ#2UZ	!*No append; modified				!
Z      F<		!**** Go get next command			!
Z    '			!*End of ^Z-^F execution			!
Z
Z    QT-7"E		!*If command is an ^Z-^G then			!
Z      F<		!**** Go get next command			!
Z    '			!*End off ^Z-^G execution			!
Z
Z    QT-26"E		!*If command is ^Z-^Z then close files and exit	!
Z      8&QZ"N		!*If output file is open then			!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          EC		!*Move rest of file to output and close file	!
Z        |		!*Else if buffer has not been modified then	!
Z          EK		!*Kill the output file				!
Z        '		!*End of output open processing			!
Z      |			!*Else if output file is not open then		!
Z        2&QZ"N		!*If buffer has been modified then		!
Z          MU		!*Take steps to save or purge buffer		!
Z          "U		!*If aborted then				!
Z            F<		!**** Go get next command			!
Z          '		!*End of abort trap				!
Z        '		!*End of modified buffer test			!
Z      '			!*End of output file open/closed processing	!
Z      ^^HMM		!*Send cursor home				!
Z      ^^JMM		!*Erase screen					!
Z      HK		!*Purge the buffer to insure exit capability	!
Z      EX		!*Exit the editor				!
Z    '			!*End of ^Z-^Z execution			!
Z
Z    7MM			!*ESC-X command not found; ring bell		!
Z    32768W		!*Forget that we rang terminal's bell (she did)	!
Z    F<			!**** Go get next command			!
Z   
Z  >			!*						!
Z~
Z   
Z!* END OF MACRO LOADS INTO Q REGISTERS					!
Z   
ZHK			!*Purge the buffer				!
ZMI			!*Begin execution of infinite iteration		!
Z!BY!			!*Jump in point for non-EMACS bypass		!
ZEI
STUNKYFLUFF
set `sum emacs11.tec`
if test 48995 != $1
then
echo emacs11.tec: Checksum error. Is: $1, should be: 48995.
fi
#
#
echo Extracting vaxbld.tec:
sed 's/^Z//' >vaxbld.tec <<\STUNKYFLUFF
Z!  VAXBLD.TEC --- TECO command file to strip the [FISH.EMACS]EMACS.SRC !
Z!                   File of all extraneous characters such as !
Z!                   comments, blanks, tabs, and CRLF's.  This !
Z!                   results in TECO macro file called  !
Z!                   [FISH.EMACS]EMACS.TEC which is of minimum possible size. !
Z
Z!  NOTE:  This file contains two non-printing characters; !
Z!         a pair of ESC's at the end !
Z
Z1^_&ED#2ED                 ! ^ means control in searchs; no yank prot !
ZET#64ET                    ! Run in detached mode !
Z@ER/[FISH.EMACS]EMACS.SRC/           ! Open source file !
Z@EW/[FISH.EMACS]EMACS.TEC/              ! Open destination file !
Z@_/!* START !/             ! Find the code start point !
Z0L
ZK
Z@^UI|
Z  A
Z  <
Z    .UB
Z    @^A%Removing comments%
Z    13^T
Z    10^T
Z    <
Z      @:S/!*/
Z      ;
Z      2R
Z      K
Z    > 
Z    QBJ
Z    @^A%Replacing CRLFs with blanks%
Z    13^T
Z    10^T
Z    <
Z      @:S/^EL/
Z      ;
Z      -1A-10"E
Z        -2D
Z        @I/ /
Z      '
Z    >
Z    QBJ
Z    @^A%Compressing blanks and tabs%
Z    13^T
Z    10^T
Z    <
Z      @:FS/^ES/ /
Z      ;
Z    >
Z    QBJ
Z    @^A%Restructuring lines%
Z    13^T
Z    10^T
Z    <
Z      Z-.-80U2
Z      Q2"G
Z        80C
Z        @:-FS/ //
Z        ;
Z        13@I//
Z        10@I//
Z      '
Z      -Q2;
Z    >    
Z    ^N"N
Z      @^A%EOF found%
Z      13^T
Z      10^T
Z      0;
Z    '
Z    @^A%Getting next page%
Z    13^T
Z    10^T
Z    A
Z  >
Z|
ZMI
ZEC
Z@EB/[FISH.EMACS]EMACS.TEC/
ZMI
ZJ
Z@^A%Final blank compression%
Z13^T
Z10^T
Z<
Z  @:FS/ //
Z  ;
Z>
Z1ET
Z27^T
Z7^T
Z@^A% Done !!!%
Z13^T
Z10^T
ZEX
Z                         ! Close files and exit ! 
STUNKYFLUFF
set `sum vaxbld.tec`
if test 47133 != $1
then
echo vaxbld.tec: Checksum error. Is: $1, should be: 47133.
fi
echo ALL DONE BUNKY!
exit 0
